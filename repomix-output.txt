This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
.repomix/bundles.json
assets/shaders/blur.wgsl
assets/shaders/post_processing.wgsl
Cargo.toml
examples/blur.rs
examples/glow.rs
examples/sample.rs
h263-rs/.git/hooks/applypatch-msg.sample
h263-rs/.git/hooks/commit-msg.sample
h263-rs/.git/hooks/fsmonitor-watchman.sample
h263-rs/.git/hooks/post-update.sample
h263-rs/.git/hooks/pre-applypatch.sample
h263-rs/.git/hooks/pre-commit.sample
h263-rs/.git/hooks/pre-merge-commit.sample
h263-rs/.git/hooks/pre-push.sample
h263-rs/.git/hooks/pre-rebase.sample
h263-rs/.git/hooks/pre-receive.sample
h263-rs/.git/hooks/prepare-commit-msg.sample
h263-rs/.git/hooks/push-to-checkout.sample
h263-rs/.git/hooks/sendemail-validate.sample
h263-rs/.git/hooks/update.sample
h263-rs/.git/info/exclude
h263-rs/.git/logs/HEAD
h263-rs/.git/logs/refs/heads/master
h263-rs/.git/logs/refs/remotes/origin/HEAD
h263-rs/.git/refs/heads/master
h263-rs/.git/refs/remotes/origin/HEAD
LICENSE-APACHE
LICENSE-MIT
Readme.md
src/assets.rs
src/bundle.rs
src/lib.rs
src/plugin.rs
src/render.rs
src/render/blend_pipeline.rs
src/render/filter/blur.rs
src/render/filter/mod.rs
src/render/material.rs
src/render/node.rs
src/render/shaders/bitmap.wgsl
src/render/shaders/color.wgsl
src/render/shaders/filters/blur.wgsl
src/render/shaders/gradient.wgsl
src/render/tessellator.rs
src/swf.rs
src/swf/characters.rs
src/swf/container.rs
src/swf/display_object.rs
src/swf/display_object/graphic.rs
src/swf/display_object/movie_clip.rs
src/swf/library.rs
src/swf/tag_utils.rs
swf_macro/Cargo.toml
swf_macro/src/lib.rs

================================================================
Files
================================================================

================
File: .gitignore
================
/target
/.idea

================
File: .repomix/bundles.json
================
{
  "bundles": {}
}

================
File: assets/shaders/blur.wgsl
================
#import bevy_core_pipeline::fullscreen_vertex_shader::FullscreenVertexOutput

struct BlurFilter {
    // Secretly a vec2<f32> but within alignment rules.
    // One of these is always 0.0, the other is 1.0.
    dir_x: f32,
    dir_y: f32,

    // Full size of the blur kernel.
    full_size: f32,

    // The number of trivially sampleable pixel pairs in the middle.
    m: f32,

    // This is m * 2.0: # of trivially sampleable pixels (not pairs) in the middle.
    m2: f32,

    // The weight of the first sampled pixel - computed as alpha in Rust.
    first_weight: f32,

    // These control the fused sampling of the last pixel pair.
    last_offset: f32,
    last_weight: f32,
}

@group(0) @binding(0) var texture: texture_2d<f32>;
@group(0) @binding(1) var texture_sampler: sampler;

@group(0) @binding(2) var<uniform> filter_args: BlurFilter;


@fragment
fn fragment(in: FullscreenVertexOutput) -> @location(0) vec4<f32> {
    let uv = in.uv - in.uv * filter_args.m;
    let direction = vec2<f32>(filter_args.dir_x, filter_args.dir_y);

    var total = vec4<f32>(0.0);

    // The first (potentially fractional) pixel, to the left of the trivial pixel pairs.
    total += textureSample(texture, texture_sampler, uv - direction) * filter_args.first_weight;

    var center = vec4<f32>();
    for (var i = 0.5; i < filter_args.m2; i += 2.0) {
        // The center of the kernel is always going to be 1,1 weight pairs.
        // We can just sample between the two pixels and multiply by 2.0.
        // The +0.5 offset is baked right into i. This doesn't affect the
        // iteration (which has a granularity of 2.0, and is open-ended),
        // but saves an addition here in the loop body.
        center += textureSample(texture, texture_sampler, uv + direction * i);
    }
    total += center * 2.0;

    // The last pixel pair, the second of which may have fractional weight, sampled together.
    let last_location = uv + direction * (filter_args.m2 + filter_args.last_offset);
    total += textureSample(texture, texture_sampler, last_location) * filter_args.last_weight;

    // The sum of every weight is full_size.
    let result = total / filter_args.full_size;

    // This rounding imitates the fixed-point computations of FP, improving emulation accuracy.
    // return floor(result * 255.0) / 255.0;
    return vec4<f32>(0.0, 0.0, 1.0, 1.0);
}

================
File: assets/shaders/post_processing.wgsl
================
#import bevy_core_pipeline::fullscreen_vertex_shader::FullscreenVertexOutput

struct BlurFilter {
    // Secretly a vec2<f32> but within alignment rules.
    // One of these is always 0.0, the other is 1.0.
    dir_x: f32,
    dir_y: f32,

    // Full size of the blur kernel.
    full_size: f32,

    // The number of trivially sampleable pixel pairs in the middle.
    m: f32,

    // This is m * 2.0: # of trivially sampleable pixels (not pairs) in the middle.
    m2: f32,

    // The weight of the first sampled pixel - computed as alpha in Rust.
    first_weight: f32,

    // These control the fused sampling of the last pixel pair.
    last_offset: f32,
    last_weight: f32,
}

@group(0) @binding(0) var texture: texture_2d<f32>;
@group(0) @binding(1) var texture_sampler: sampler;

const filter_args: BlurFilter = BlurFilter(
    0.0016835016,
    0.0,
    152.25,
    75.0,
    150.0,
    0.62352943,
    0.38405797,
    1.6235294,
);

@fragment
fn fragment(in: FullscreenVertexOutput) -> @location(0) vec4<f32> {
    let direction = vec2<f32>(filter_args.dir_x, filter_args.dir_y);
    let uv = in.uv - direction * filter_args.m;

    var total = vec4<f32>(0.0);

    // The first (potentially fractional) pixel, to the left of the trivial pixel pairs.
    total += textureSample(texture, texture_sampler, uv - direction) * filter_args.first_weight;

    var center = vec4<f32>();
    for (var i = 0.5; i < filter_args.m2; i += 2.0) {
        // The center of the kernel is always going to be 1,1 weight pairs.
        // We can just sample between the two pixels and multiply by 2.0.
        // The +0.5 offset is baked right into i. This doesn't affect the
        // iteration (which has a granularity of 2.0, and is open-ended),
        // but saves an addition here in the loop body.
        center += textureSample(texture, texture_sampler, uv + direction * i);
    }
    total += center * 2.0;

    // The last pixel pair, the second of which may have fractional weight, sampled together.
    let last_location = uv + direction * (filter_args.m2 + filter_args.last_offset);
    total += textureSample(texture, texture_sampler, last_location) * filter_args.last_weight;

    // The sum of every weight is full_size.
    let result = total / filter_args.full_size;

    // This rounding imitates the fixed-point computations of FP, improving emulation accuracy.
    return floor(result * 255.0) / 255.0;
}

================
File: Cargo.toml
================
[package]
name = "bevy_flash"
version = "0.1.0"
edition = "2021"
authors = ["傲娇小霖霖"]
license = "MIT OR Apache-2.0"
description = "A Bevy plugin for Flash Animation"

[dependencies]
swf = { git = "https://github.com/ruffle-rs/ruffle.git", tag = "nightly-2024-12-09" }
ruffle_render = { git = "https://github.com/ruffle-rs/ruffle.git", tag = "nightly-2024-12-09" }
ruffle_render_wgpu = { git = "https://github.com/ruffle-rs/ruffle.git", tag = "nightly-2024-12-09" }
ruffle_macros = { git = "https://github.com/ruffle-rs/ruffle.git", tag = "nightly-2024-12-09" }
swf_macro = { path = "./swf_macro" }
smallvec = { version = "1.13.2", features = ["union"] }
wgpu = { version = "23", default-features = false }

bevy = { path = "../bevy", default-features = false, features = [
    "bevy_asset",
    "bevy_sprite",
] }

thiserror = "1.0"
anyhow = "1.0"
bitflags = "2.5"
lyon_tessellation = "1.0"
indexmap = "2.7"
copyless = "0.1.5"

uuid = "1.10"
enum-map = "2.7.3"

[dev-dependencies]
bevy = { path = "../bevy", features = ["bevy_dev_tools"] }


[profile.dev]
opt-level = 1

================
File: examples/blur.rs
================
use bevy::{
    app::{App, Plugin, Startup},
    asset::{Assets, DirectAssetAccessExt},
    color::{palettes::css::RED, Color},
    core_pipeline::{
        core_2d::graph::{Core2d, Node2d},
        fullscreen_vertex_shader::fullscreen_shader_vertex_state,
    },
    image::BevyDefault,
    math::Vec3,
    prelude::{
        Camera, Camera2d, Commands, Component, FromWorld, Mesh, Mesh2d, Rectangle, ResMut,
        Resource, Transform,
    },
    render::{
        extract_component::{ExtractComponent, ExtractComponentPlugin},
        render_graph::{RenderGraphApp, RenderLabel, ViewNode, ViewNodeRunner},
        render_resource::{
            binding_types::{sampler, texture_2d},
            BindGroupEntries, BindGroupLayout, BindGroupLayoutEntries, CachedRenderPipelineId,
            FragmentState, PipelineCache, RenderPipelineDescriptor, Sampler,
        },
        renderer::RenderDevice,
        view::ViewTarget,
        RenderApp,
    },
    sprite::{ColorMaterial, MeshMaterial2d},
    DefaultPlugins,
};
use wgpu::{
    ColorTargetState, ColorWrites, MultisampleState, Operations, PrimitiveState,
    RenderPassColorAttachment, RenderPassDescriptor, ShaderStages,
};
fn main() {
    App::new()
        .add_plugins((DefaultPlugins, PostProcessPlugin))
        .add_systems(Startup, setup)
        .run();
}

fn setup(
    mut commands: Commands,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<ColorMaterial>>,
) {
    commands.spawn((
        Camera2d,
        Camera {
            clear_color: Color::NONE.into(),
            ..Default::default()
        },
        PostProcessIdentify,
    ));
    commands.spawn((
        Mesh2d(meshes.add(Mesh::from(Rectangle::default()))),
        MeshMaterial2d(materials.add(Color::from(RED))),
        Transform::from_scale(Vec3::splat(64.0)),
    ));
}

#[derive(Resource)]
struct PostProcessPipeline {
    layout: BindGroupLayout,
    sampler: Sampler,
    pipeline_id: CachedRenderPipelineId,
}

impl FromWorld for PostProcessPipeline {
    fn from_world(world: &mut bevy::prelude::World) -> Self {
        let render_device = world.resource::<RenderDevice>();
        let layout = render_device.create_bind_group_layout(
            "后置处理绑定组",
            &BindGroupLayoutEntries::sequential(
                ShaderStages::VERTEX_FRAGMENT,
                (
                    texture_2d(wgpu::TextureSampleType::Float { filterable: true }),
                    sampler(wgpu::SamplerBindingType::Filtering),
                ),
            ),
        );

        let sampler = render_device.create_sampler(&wgpu::SamplerDescriptor::default());

        let shader = world.load_asset("shaders/post_processing.wgsl");

        let pipeline_id =
            world
                .resource_mut::<PipelineCache>()
                .queue_render_pipeline(RenderPipelineDescriptor {
                    label: Some("后置处理管线".into()),
                    layout: vec![layout.clone()],
                    vertex: fullscreen_shader_vertex_state(),
                    fragment: Some(FragmentState {
                        shader,
                        shader_defs: vec![],
                        entry_point: "fragment".into(),
                        targets: vec![Some(ColorTargetState {
                            format: wgpu::TextureFormat::bevy_default(),
                            blend: None,
                            write_mask: ColorWrites::ALL,
                        })],
                    }),
                    primitive: PrimitiveState::default(),
                    depth_stencil: None,
                    multisample: MultisampleState::default(),
                    push_constant_ranges: vec![],
                    zero_initialize_workgroup_memory: false,
                });
        Self {
            layout,
            sampler,
            pipeline_id,
        }
    }
}

#[derive(Component, ExtractComponent, Clone)]
struct PostProcessIdentify;

/// 该后置处理只能针对一个`Camera2d`中实体进行处理
#[derive(Default)]
struct PostProcessNode;

impl ViewNode for PostProcessNode {
    type ViewQuery = (&'static ViewTarget, &'static PostProcessIdentify);

    fn run<'w>(
        &self,
        _graph: &mut bevy::render::render_graph::RenderGraphContext,
        render_context: &mut bevy::render::renderer::RenderContext<'w>,
        (view_target, _): bevy::ecs::query::QueryItem<'w, Self::ViewQuery>,
        world: &'w bevy::prelude::World,
    ) -> Result<(), bevy::render::render_graph::NodeRunError> {
        let post_process_pipeline = world.resource::<PostProcessPipeline>();

        let pipeline_cache = world.resource::<PipelineCache>();
        let Some(pipeline) = pipeline_cache.get_render_pipeline(post_process_pipeline.pipeline_id)
        else {
            return Ok(());
        };

        let post_process = view_target.post_process_write();

        let bind_group = render_context.render_device().create_bind_group(
            "后置处理绑定组",
            &post_process_pipeline.layout,
            &BindGroupEntries::sequential((post_process.source, &post_process_pipeline.sampler)),
        );

        let mut render_pass = render_context.begin_tracked_render_pass(RenderPassDescriptor {
            label: Some("后置处理管道"),
            color_attachments: &[Some(RenderPassColorAttachment {
                view: post_process.destination,
                resolve_target: None,
                ops: Operations::default(),
            })],
            depth_stencil_attachment: None,
            timestamp_writes: None,
            occlusion_query_set: None,
        });
        render_pass.set_render_pipeline(pipeline);
        render_pass.set_bind_group(0, &bind_group, &[]);
        render_pass.draw(0..3, 0..1);

        Ok(())
    }
}
#[derive(Debug, Hash, PartialEq, Eq, Clone, RenderLabel)]
struct PostProcessLabel;
struct PostProcessPlugin;
impl Plugin for PostProcessPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(ExtractComponentPlugin::<PostProcessIdentify>::default());
        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
            return;
        };
        render_app
            .add_render_graph_node::<ViewNodeRunner<PostProcessNode>>(Core2d, PostProcessLabel)
            .add_render_graph_edges(
                Core2d,
                (
                    Node2d::Tonemapping,
                    PostProcessLabel,
                    Node2d::EndMainPassPostProcessing,
                ),
            );
    }

    fn finish(&self, app: &mut App) {
        // We need to get the render app from the main app
        let Some(render_app) = app.get_sub_app_mut(RenderApp) else {
            return;
        };

        render_app
            // Initialize the pipeline
            .init_resource::<PostProcessPipeline>();
    }
}

================
File: examples/glow.rs
================
use bevy::{
    app::{App, Startup},
    asset::AssetServer,
    color::Color,
    prelude::{Camera2d, ClearColor, Commands, Res},
    DefaultPlugins,
};
use bevy_flash::{bundle::FlashAnimation, plugin::FlashPlugin};

fn main() {
    App::new()
        .insert_resource(ClearColor(Color::srgb(
            102.0 / 255.0,
            102.0 / 255.0,
            102.0 / 255.0,
        )))
        .add_plugins((DefaultPlugins, FlashPlugin))
        .add_systems(Startup, setup)
        .run();
}

fn setup(mut commands: Commands, assert_server: Res<AssetServer>) {
    commands.spawn(Camera2d);
    commands.spawn(FlashAnimation {
        swf_movie: assert_server.load("glow.swf"),
        ..Default::default()
    });
}

================
File: examples/sample.rs
================
use bevy::{
    app::{App, Startup, Update},
    asset::{AssetServer, Assets},
    color::Color,
    dev_tools::fps_overlay::FpsOverlayPlugin,
    input::ButtonInput,
    math::Vec3,
    prelude::{
        Camera2d, ClearColor, Commands, Entity, EventReader, KeyCode, Msaa, Query, Res, ResMut,
        Transform,
    },
    DefaultPlugins,
};
use bevy_flash::{
    assets::SwfMovie,
    plugin::{FlashPlugin, SwfInitEvent},
};
use bevy_flash::{
    bundle::FlashAnimation,
    swf::display_object::{movie_clip::NextFrame, TDisplayObject},
};

fn main() {
    App::new()
        .insert_resource(ClearColor(Color::srgb(
            102.0 / 255.0,
            102.0 / 255.0,
            102.0 / 255.0,
        )))
        .add_plugins((DefaultPlugins, FlashPlugin, FpsOverlayPlugin::default()))
        .add_systems(Startup, setup)
        .add_systems(Update, control)
        .run();
}

fn setup(mut commands: Commands, assert_server: Res<AssetServer>) {
    commands.spawn((Camera2d, Msaa::Sample8));
    commands.spawn((
        FlashAnimation {
            name: Some(String::from("mc")),
            swf_movie: assert_server.load("spirit2159src.swf"),
            ..Default::default()
        },
        Transform::from_translation(Vec3::new(00.0, 00.0, 0.0)).with_scale(Vec3::splat(2.0)),
    ));

    commands.spawn((
        FlashAnimation {
            name: Some(String::from("m")),
            swf_movie: assert_server.load("131381-idle.swf"),
            ..Default::default()
        },
        Transform::from_translation(Vec3::new(-800.0, 200.0, 0.0)).with_scale(Vec3::splat(6.0)),
    ));
    // commands.spawn(FlashAnimation {
    //     name: Some(String::from("blend_add")),
    //     swf_movie: assert_server.load("blend_add.swf"),
    //     ignore_root_swf_transform: false,
    //     ..Default::default()
    // });
    // commands.spawn((
    //     FlashAnimation {
    //         name: Some(String::from("blend_sub")),
    //         swf_movie: assert_server.load("blend_sub.swf"),
    //         ignore_root_swf_transform: false,
    //         ..Default::default()
    //     },
    //     Transform::from_translation(Vec3::new(-400.0, 0.0, 0.0)),
    // ));
    // commands.spawn((
    //     FlashAnimation {
    //         name: Some(String::from("blend_screen")),
    //         swf_movie: assert_server.load("blend_screen.swf"),
    //         ignore_root_swf_transform: false,
    //         ..Default::default()
    //     },
    //     Transform::from_translation(Vec3::new(-800.0, 0.0, 0.0)),
    // ));
}

fn control(
    mut query: Query<(&mut FlashAnimation, Entity)>,
    mut swf_movies: ResMut<Assets<SwfMovie>>,
    keyboard_input: Res<ButtonInput<KeyCode>>,
    mut swf_init_event: EventReader<SwfInitEvent>,
) {
    for swf_init_event in swf_init_event.read() {
        query.iter_mut().for_each(|(flash_animation, entity)| {
            let name = flash_animation.name.clone();
            if let Some(swf_movie) = swf_movies.get_mut(flash_animation.swf_movie.id()) {
                swf_movie.root_movie_clip.set_name(name);
                if swf_init_event.0 == entity {
                    swf_movie
                        .root_movie_clip
                        .goto_frame(&mut swf_movie.movie_library, 0, true);
                }
            }
        });
    }

    query.iter_mut().for_each(|(flash_animation, _)| {
        if let Some(swf_movie) = swf_movies.get_mut(flash_animation.swf_movie.id()) {
            if flash_animation.name.as_deref() == Some("mc") {
                if let Some(first_child_movie_clip) =
                    swf_movie.root_movie_clip.first_child_movie_clip()
                {
                    if matches!(
                        first_child_movie_clip.determine_next_frame(),
                        NextFrame::First
                    ) {
                        swf_movie.root_movie_clip.goto_frame(
                            &mut swf_movie.movie_library,
                            20,
                            true,
                        );
                    }
                }
            }
        }
    });

    let mut control = |query: &mut Query<'_, '_, (&mut FlashAnimation, Entity)>, frame: u16| {
        query.iter_mut().for_each(|(flash_animation, _)| {
            if let Some(swf_movie) = swf_movies.get_mut(flash_animation.swf_movie.id()) {
                if flash_animation.name.as_deref() == Some("mc") {
                    swf_movie
                        .root_movie_clip
                        .goto_frame(&mut swf_movie.movie_library, frame, true);
                }
            }
        });
    };

    if keyboard_input.just_released(KeyCode::KeyW) {
        control(&mut query, 0);
    }

    if keyboard_input.just_released(KeyCode::KeyA) {
        control(&mut query, 10);
    }

    if keyboard_input.just_released(KeyCode::KeyS) {
        control(&mut query, 20);
    }

    if keyboard_input.just_released(KeyCode::KeyD) {
        control(&mut query, 30);
    }

    if keyboard_input.just_released(KeyCode::KeyF) {
        control(&mut query, 40);
    }

    if keyboard_input.just_released(KeyCode::KeyH) {
        control(&mut query, 50);
    }

    if keyboard_input.just_released(KeyCode::KeyJ) {
        control(&mut query, 60);
    }

    if keyboard_input.just_released(KeyCode::KeyK) {
        control(&mut query, 70);
    }

    if keyboard_input.just_released(KeyCode::KeyL) {
        control(&mut query, 80);
    }

    if keyboard_input.just_released(KeyCode::KeyM) {
        control(&mut query, 90);
    }

    if keyboard_input.just_released(KeyCode::KeyN) {
        control(&mut query, 100);
    }

    if keyboard_input.just_released(KeyCode::KeyO) {
        control(&mut query, 110);
    }

    // query.iter().for_each(|(swf, _)| {
    //     let movie_clip = &swf.root_movie_clip;
    //     println!("MovieClip:{}", movie_clip.character_id());
    //     let space = 0;
    //     show(movie_clip, space);
    // });

    // println!("-------------end----------------------");
}

================
File: h263-rs/.git/hooks/applypatch-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

================
File: h263-rs/.git/hooks/commit-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

================
File: h263-rs/.git/hooks/fsmonitor-watchman.sample
================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

================
File: h263-rs/.git/hooks/post-update.sample
================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

================
File: h263-rs/.git/hooks/pre-applypatch.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

================
File: h263-rs/.git/hooks/pre-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

================
File: h263-rs/.git/hooks/pre-merge-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

================
File: h263-rs/.git/hooks/pre-push.sample
================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

================
File: h263-rs/.git/hooks/pre-rebase.sample
================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

================
File: h263-rs/.git/hooks/pre-receive.sample
================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

================
File: h263-rs/.git/hooks/prepare-commit-msg.sample
================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

================
File: h263-rs/.git/hooks/push-to-checkout.sample
================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

================
File: h263-rs/.git/hooks/sendemail-validate.sample
================
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

================
File: h263-rs/.git/hooks/update.sample
================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

================
File: h263-rs/.git/info/exclude
================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

================
File: h263-rs/.git/logs/HEAD
================
0000000000000000000000000000000000000000 07468962d9c57c0780f3e9abf046186f5be58a26 傲娇小霖霖 <1589861957@qq.com> 1734244567 +0800	clone: from https://github.com/ruffle-rs/h263-rs.git

================
File: h263-rs/.git/logs/refs/heads/master
================
0000000000000000000000000000000000000000 07468962d9c57c0780f3e9abf046186f5be58a26 傲娇小霖霖 <1589861957@qq.com> 1734244567 +0800	clone: from https://github.com/ruffle-rs/h263-rs.git

================
File: h263-rs/.git/logs/refs/remotes/origin/HEAD
================
0000000000000000000000000000000000000000 07468962d9c57c0780f3e9abf046186f5be58a26 傲娇小霖霖 <1589861957@qq.com> 1734244567 +0800	clone: from https://github.com/ruffle-rs/h263-rs.git

================
File: h263-rs/.git/refs/heads/master
================
07468962d9c57c0780f3e9abf046186f5be58a26

================
File: h263-rs/.git/refs/remotes/origin/HEAD
================
ref: refs/remotes/origin/master

================
File: LICENSE-APACHE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: LICENSE-MIT
================
MIT License

Copyright (c) 2024 傲娇小霖霖

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: Readme.md
================
# bevy_flash

## Rendering flash animation in bevy engine

## Example

[See online demo](https://aojiaoxiaolinlin.github.io/bevy_flash_demo/)

- run example

```bash
cargo run --package bevy_flash --example sample
```

![展示](./assets/docs/xiao_hai_shen_long.png)

> Reference [Ruffle](https://github.com/ruffle-rs/ruffle/);

## Support

- [x] Shape Render
- [x] MovieClip Animation
- [x] Control Animation
- [ ] Blend Render
- [ ] Filter Render

## License

This code is licensed under dual MIT / Apache-2.0 but with no attribution necessary. All contributions must agree to this licensing.

================
File: src/assets.rs
================
use std::sync::Arc;

use bevy::{
    asset::{io::Reader, Asset, AssetLoader, LoadContext},
    reflect::TypePath,
};

use crate::swf::{display_object::movie_clip::MovieClip, library::MovieLibrary, tag_utils};

#[derive(Asset, TypePath)]
pub struct SwfMovie {
    pub swf_movie: Arc<tag_utils::SwfMovie>,
    pub movie_library: MovieLibrary,
    pub root_movie_clip: MovieClip,
}

#[derive(Default)]
pub(crate) struct SwfLoader;

impl AssetLoader for SwfLoader {
    type Asset = SwfMovie;

    type Settings = ();

    type Error = tag_utils::Error;
    async fn load(
        &self,
        reader: &mut dyn Reader,
        _settings: &(),
        _load_context: &mut LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        let mut swf_data = Vec::new();
        reader.read_to_end(&mut swf_data).await?;
        let swf_movie = Arc::new(tag_utils::SwfMovie::from_data(&swf_data[..])?);
        Ok(SwfMovie {
            swf_movie,
            movie_library: MovieLibrary::new(),
            root_movie_clip: MovieClip::default(),
        })
    }

    fn extensions(&self) -> &[&str] {
        &["swf"]
    }
}

================
File: src/bundle.rs
================
use bevy::{
    asset::Handle,
    prelude::{Component, Entity, ReflectComponent, ReflectDefault, Transform, Visibility},
    reflect::Reflect,
    utils::hashbrown::HashMap,
};
use swf::{CharacterId, Depth};

use crate::assets::SwfMovie;

#[derive(Default, Clone, Copy, PartialEq, Eq, Hash, Debug, Reflect)]
pub struct ShapeMark {
    // 记录shape被多次引用的情况
    pub graphic_ref_count: u8,
    pub depth: Depth,
    pub id: CharacterId,
}

#[derive(Default, Clone, Debug, Reflect)]
#[reflect(Default)]
pub struct ShapeMarkEntities {
    graphic_entities: HashMap<ShapeMark, Entity>,
    current_frame_entities: Vec<ShapeMark>,
}

impl ShapeMarkEntities {
    pub fn entity(&self, shape_mark: &ShapeMark) -> Option<&Entity> {
        self.graphic_entities.get(shape_mark)
    }

    pub fn add_entities_pool(&mut self, shape_mark: ShapeMark, entity: Entity) {
        self.graphic_entities.insert(shape_mark, entity);
    }

    pub fn record_current_frame_entity(&mut self, shape_mark: ShapeMark) {
        self.current_frame_entities.push(shape_mark);
    }

    pub fn clear_current_frame_entity(&mut self) {
        self.current_frame_entities.clear();
    }

    pub fn graphic_entities(&self) -> &HashMap<ShapeMark, Entity> {
        &self.graphic_entities
    }

    pub fn current_frame_entities(&self) -> &Vec<ShapeMark> {
        &self.current_frame_entities
    }
}

#[derive(Default, Debug, Clone, Reflect)]
pub enum SwfState {
    #[default]
    Loading,
    Ready,
}

#[derive(Default, Component)]
#[require(Transform, Visibility)]
pub struct SwfGraphicComponent;

#[derive(Component, Debug, Clone, Reflect)]
#[require(Transform, Visibility)]
#[reflect(Component, Default, Debug)]
pub struct FlashAnimation {
    /// 要渲染的swf资源的引用计数句柄。
    pub swf_movie: Handle<SwfMovie>,
    /// 要渲染和控制的movie_clip，影片默认为根影片
    pub name: Option<String>,
    /// 加载处理状态
    pub status: SwfState,
    /// shape对应实体
    pub shape_mark_entities: ShapeMarkEntities,
    /// 是否应用根影片的变换 默认为true，不会应用根影片的变换; 若为false则会应用根影片的变换
    pub ignore_root_swf_transform: bool,
}

impl Default for FlashAnimation {
    fn default() -> Self {
        Self {
            swf_movie: Default::default(),
            name: None,
            status: Default::default(),
            shape_mark_entities: Default::default(),
            ignore_root_swf_transform: true,
        }
    }
}

================
File: src/lib.rs
================
pub mod assets;
pub mod bundle;
pub mod plugin;
pub mod render;
pub mod swf;

================
File: src/plugin.rs
================
use crate::assets::{SwfLoader, SwfMovie};
use crate::bundle::{FlashAnimation, SwfState};
use crate::render::material::{
    BitmapMaterial, GradientMaterial, GradientUniforms, SwfColorMaterial,
};
use crate::render::tessellator::ShapeTessellator;
use crate::render::FlashRenderPlugin;
use crate::swf::characters::Character;
use crate::swf::display_object::movie_clip::MovieClip;
use crate::swf::display_object::TDisplayObject;
use crate::swf::library::MovieLibrary;
use bevy::app::App;
use bevy::asset::{AssetEvent, Handle};
use bevy::color::{Color, ColorToComponents};
use bevy::log::error;
use bevy::math::{Mat3, Mat4};
use bevy::prelude::{
    Entity, Event, EventReader, EventWriter, Image, IntoSystemConfigs, Mesh, Query, Resource,
};
use bevy::render::mesh::Indices;
use bevy::render::render_asset::RenderAssetUsages;
use bevy::time::{Time, Timer, TimerMode};
use bevy::{
    app::{Plugin, Update},
    asset::{AssetApp, Assets},
    prelude::{Res, ResMut},
};
use copyless::VecHelper;
use ruffle_render::tessellator::DrawType;
use swf::GradientInterpolation;
use wgpu::{Extent3d, PrimitiveTopology};

/// 制作多大得渐变纹理，越大细节越丰富，但是内存占用也越大
const GRADIENT_SIZE: usize = 256;

#[derive(Resource)]
struct FlashPlayerTimer(Timer);

pub struct FlashPlugin;

impl Plugin for FlashPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(FlashRenderPlugin)
            .add_event::<SwfInitEvent>()
            .init_asset::<SwfMovie>()
            .init_asset_loader::<SwfLoader>()
            .insert_resource(FlashPlayerTimer(Timer::from_seconds(
                // TODO: 24fps
                1. / 24.,
                TimerMode::Repeating,
            )))
            .add_systems(Update, (pre_parse, enter_frame).chain());
    }
}

fn enter_frame(
    mut query: Query<&mut FlashAnimation>,
    mut swf_movies: ResMut<Assets<SwfMovie>>,
    time: Res<Time>,
    mut timer: ResMut<FlashPlayerTimer>,
) {
    if timer.0.tick(time.delta()).just_finished() {
        for mut flash_animation in query.iter_mut() {
            if let Some(swf_movie) = swf_movies.get_mut(flash_animation.swf_movie.id()) {
                swf_movie
                    .root_movie_clip
                    .enter_frame(&mut swf_movie.movie_library);
                flash_animation.status = SwfState::Ready;
            }
        }
    }
}

#[derive(Clone)]
pub enum ShapeDrawType {
    Color(SwfColorMaterial),
    Gradient(GradientMaterial),
    Bitmap(BitmapMaterial),
}
#[derive(Clone)]
pub struct ShapeMesh {
    pub mesh: Handle<Mesh>,
    pub draw_type: ShapeDrawType,
}
#[derive(Event)]
pub struct SwfInitEvent(pub Entity);

fn pre_parse(
    mut query: Query<(&mut FlashAnimation, Entity)>,
    mut swf_events: EventReader<AssetEvent<SwfMovie>>,
    mut swf_movies: ResMut<Assets<SwfMovie>>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut images: ResMut<Assets<Image>>,
    mut swf_init_events: EventWriter<SwfInitEvent>,
) {
    for event in swf_events.read() {
        if let AssetEvent::LoadedWithDependencies { id } = event {
            if let Some(swf_movie) = swf_movies.get_mut(*id) {
                let swf_movie_data = swf_movie.swf_movie.clone();
                let mut root_movie_clip = MovieClip::new(swf_movie_data);
                let mut library = MovieLibrary::new();
                root_movie_clip.parse_swf(&mut library);
                root_movie_clip.current_frame = 0;
                let library_clone = library.clone();
                library
                    .characters_mut()
                    .iter_mut()
                    .for_each(|(_id, character)| {
                        if let Character::Graphic(graphic) = character {
                            let mut shape_tessellator = ShapeTessellator::new();
                            let lyon_mesh = shape_tessellator
                                .tessellate_shape((&graphic.shape).into(), &library_clone);

                            let gradients = lyon_mesh.gradients;
                            let mut gradients_texture = Vec::new();
                            for gradient in gradients {
                                let colors = if gradient.records.is_empty() {
                                    vec![0; GRADIENT_SIZE * 4]
                                } else {
                                    let mut colors = vec![0; GRADIENT_SIZE * 4];
                                    let convert = if gradient.interpolation
                                        == GradientInterpolation::LinearRgb
                                    {
                                        |color| color
                                    } else {
                                        |color| color
                                    };

                                    for t in 0..GRADIENT_SIZE {
                                        let mut last = 0;
                                        let mut next = 0;
                                        for (i, record) in gradient.records.iter().enumerate().rev()
                                        {
                                            if (record.ratio as usize) < t {
                                                last = i;
                                                next = (i + 1).min(gradient.records.len() - 1);
                                                break;
                                            }
                                        }
                                        assert!(last == next || last + 1 == next);
                                        let last_record = &gradient.records[last];
                                        let next_record = &gradient.records[next];
                                        let factor = if next == last {
                                            0.0
                                        } else {
                                            (t as f32 - last_record.ratio as f32)
                                                / (next_record.ratio as f32
                                                    - last_record.ratio as f32)
                                        };

                                        colors[t * 4] = lerp(
                                            convert(last_record.color.r as f32),
                                            convert(next_record.color.r as f32),
                                            factor,
                                        )
                                            as u8;
                                        colors[(t * 4) + 1] = lerp(
                                            convert(last_record.color.g as f32),
                                            convert(next_record.color.g as f32),
                                            factor,
                                        )
                                            as u8;
                                        colors[(t * 4) + 2] = lerp(
                                            convert(last_record.color.b as f32),
                                            convert(next_record.color.b as f32),
                                            factor,
                                        )
                                            as u8;
                                        colors[(t * 4) + 3] = lerp(
                                            last_record.color.a as f32,
                                            next_record.color.a as f32,
                                            factor,
                                        )
                                            as u8;
                                    }
                                    colors
                                };

                                let texture = Image::new(
                                    wgpu::Extent3d {
                                        width: GRADIENT_SIZE as u32,
                                        height: 1,
                                        depth_or_array_layers: 1,
                                    },
                                    wgpu::TextureDimension::D2,
                                    colors,
                                    wgpu::TextureFormat::Rgba8Unorm,
                                    RenderAssetUsages::default(),
                                );

                                let gradient_uniforms = GradientUniforms::from(gradient);
                                gradients_texture.push((texture.clone(), gradient_uniforms));
                            }

                            for draw in lyon_mesh.draws {
                                match draw.draw_type {
                                    DrawType::Color => {
                                        let mut positions = Vec::with_capacity(draw.vertices.len());
                                        let mut colors = Vec::with_capacity(draw.vertices.len());
                                        for vertex in draw.vertices {
                                            // 平移顶点使得中心点在bevy原点
                                            positions.alloc().init([vertex.x, vertex.y, 0.0]);
                                            let linear_color = Color::srgba_u8(
                                                vertex.color.r,
                                                vertex.color.g,
                                                vertex.color.b,
                                                vertex.color.a,
                                            )
                                            .to_linear();
                                            colors.alloc().init(linear_color.to_f32_array());
                                        }

                                        let mut mesh = Mesh::new(
                                            PrimitiveTopology::TriangleList,
                                            RenderAssetUsages::default(),
                                        );
                                        mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
                                        mesh.insert_attribute(Mesh::ATTRIBUTE_COLOR, colors);
                                        mesh.insert_indices(Indices::U32(draw.indices));

                                        graphic.add_shape_mesh(ShapeMesh {
                                            mesh: meshes.add(mesh),
                                            draw_type: ShapeDrawType::Color(SwfColorMaterial {
                                                ..Default::default()
                                            }),
                                        });
                                    }
                                    DrawType::Gradient { matrix, gradient } => {
                                        let mut positions = Vec::with_capacity(draw.vertices.len());
                                        for vertex in draw.vertices {
                                            positions.alloc().init([vertex.x, vertex.y, 0.0]);
                                        }
                                        let mut mesh = Mesh::new(
                                            PrimitiveTopology::TriangleList,
                                            RenderAssetUsages::default(),
                                        );
                                        mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
                                        mesh.insert_indices(Indices::U32(draw.indices.clone()));
                                        let texture =
                                            gradients_texture.get(gradient).unwrap().clone();
                                        graphic.add_shape_mesh(ShapeMesh {
                                            mesh: meshes.add(mesh),
                                            draw_type: ShapeDrawType::Gradient(GradientMaterial {
                                                gradient: GradientUniforms {
                                                    focal_point: texture.1.focal_point,
                                                    interpolation: texture.1.interpolation,
                                                    shape: texture.1.shape,
                                                    repeat: texture.1.repeat,
                                                },
                                                texture_transform: Mat4::from_mat3(
                                                    Mat3::from_cols_array_2d(&matrix),
                                                ),
                                                texture: Some(images.add(texture.0)),
                                                ..Default::default()
                                            }),
                                        });
                                    }
                                    DrawType::Bitmap(bitmap) => {
                                        let texture_transform = bitmap.matrix;
                                        if let Some(compressed_bitmap) =
                                            library_clone.get_bitmap(bitmap.bitmap_id)
                                        {
                                            let decoded = match compressed_bitmap.decode() {
                                                Ok(decoded) => decoded,
                                                Err(e) => {
                                                    error!("Failed to decode bitmap: {:?}", e);
                                                    continue;
                                                }
                                            };
                                            let bitmap = decoded.to_rgba();

                                            let bitmap_texture = Image::new(
                                                Extent3d {
                                                    width: bitmap.width(),
                                                    height: bitmap.height(),
                                                    depth_or_array_layers: 1,
                                                },
                                                wgpu::TextureDimension::D2,
                                                bitmap.data().to_vec(),
                                                wgpu::TextureFormat::Rgba8Unorm,
                                                RenderAssetUsages::default(),
                                            );

                                            let mut positions =
                                                Vec::with_capacity(draw.vertices.len());
                                            for vertex in draw.vertices {
                                                positions.alloc().init([vertex.x, vertex.y, 0.0]);
                                            }
                                            let mut mesh = Mesh::new(
                                                PrimitiveTopology::TriangleList,
                                                RenderAssetUsages::default(),
                                            );
                                            mesh.insert_attribute(
                                                Mesh::ATTRIBUTE_POSITION,
                                                positions,
                                            );
                                            mesh.insert_indices(Indices::U32(draw.indices.clone()));
                                            graphic.add_shape_mesh(ShapeMesh {
                                                mesh: meshes.add(mesh),
                                                draw_type: ShapeDrawType::Bitmap(BitmapMaterial {
                                                    texture: images.add(bitmap_texture),
                                                    texture_transform: Mat4::from_mat3(
                                                        Mat3::from_cols_array_2d(
                                                            &texture_transform,
                                                        ),
                                                    ),
                                                    ..Default::default()
                                                }),
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    });
                swf_movie.movie_library = library;
                if let Some((mut flash_animation, entity)) = query
                    .iter_mut()
                    .find(|(flash_animation, _)| flash_animation.swf_movie.id() == *id)
                {
                    swf_movie.root_movie_clip = root_movie_clip.clone();
                    if flash_animation.ignore_root_swf_transform {
                        // 这里设置当前影片剪辑的根影片剪辑时，在MovieClip的实例化中就不会应用根影片的变换
                        // 如果后续根影片无其他作用，这里可以更改为更加语义化的方法名
                        swf_movie.root_movie_clip.set_root();
                    }
                    flash_animation.status = SwfState::Ready;
                    swf_init_events.send(SwfInitEvent(entity));
                }
            }
        }
    }
}

/// 线性插值
fn lerp(a: f32, b: f32, factor: f32) -> f32 {
    a + (b - a) * factor
}

================
File: src/render.rs
================
use std::{collections::BTreeMap, sync::Arc};

use bevy::prelude::ChildBuild;
use bevy::render::mesh::MeshAabb;
use bevy::sprite::BlendMode2d;
use bevy::{
    app::{App, Plugin, PostUpdate, Update},
    asset::{load_internal_asset, Assets, Handle},
    math::{Mat4, Vec3},
    prelude::{
        BuildChildren, Children, Commands, Component, Entity, IntoSystemConfigs, Mesh, Mesh2d,
        Query, Res, ResMut, Shader, Transform, Visibility, With, Without,
    },
    render::{
        view::{NoFrustumCulling, VisibilitySystems},
        RenderApp,
    },
    sprite::{Material2dPlugin, MeshMaterial2d},
};
use blend_pipeline::{BlendType, TrivialBlend};
use filter::blur::BLUR_FILTER_SHADER_HANDLE;
use material::{BitmapMaterial, GradientMaterial, SwfColorMaterial, SwfMaterial, SwfTransform};
use ruffle_render::transform::Transform as RuffleTransform;

use crate::assets::SwfMovie;
use crate::bundle::FlashAnimation;
use crate::{
    bundle::{ShapeMark, ShapeMarkEntities, SwfGraphicComponent, SwfState},
    plugin::{ShapeDrawType, ShapeMesh},
    swf::display_object::{DisplayObject, TDisplayObject},
};

pub const SWF_COLOR_MATERIAL_SHADER_HANDLE: Handle<Shader> =
    Handle::weak_from_u128(283691495474896754103765489274589);
pub const GRADIENT_MATERIAL_SHADER_HANDLE: Handle<Shader> =
    Handle::weak_from_u128(55042096615683885463288330940691701066);
pub const BITMAP_MATERIAL_SHADER_HANDLE: Handle<Shader> =
    Handle::weak_from_u128(1209708179628049255077713250256144531);

pub mod blend_pipeline;
pub mod filter;
pub(crate) mod material;
pub(crate) mod node;
pub(crate) mod tessellator;
pub struct FlashRenderPlugin;

impl Plugin for FlashRenderPlugin {
    fn build(&self, app: &mut App) {
        load_internal_asset!(
            app,
            SWF_COLOR_MATERIAL_SHADER_HANDLE,
            "render/shaders/color.wgsl",
            Shader::from_wgsl
        );
        load_internal_asset!(
            app,
            GRADIENT_MATERIAL_SHADER_HANDLE,
            "render/shaders/gradient.wgsl",
            Shader::from_wgsl
        );
        load_internal_asset!(
            app,
            BITMAP_MATERIAL_SHADER_HANDLE,
            "render/shaders/bitmap.wgsl",
            Shader::from_wgsl
        );

        load_internal_asset!(
            app,
            BLUR_FILTER_SHADER_HANDLE,
            "render/shaders/filters/blur.wgsl",
            Shader::from_wgsl
        );

        app.add_plugins(Material2dPlugin::<GradientMaterial>::default())
            .add_plugins(Material2dPlugin::<SwfColorMaterial>::default())
            .add_plugins(Material2dPlugin::<BitmapMaterial>::default())
            .add_systems(Update, render_swf)
            .add_systems(
                PostUpdate,
                calculate_shape_bounds.in_set(VisibilitySystems::CalculateBounds),
            );

        let Some(_render_app) = app.get_sub_app_mut(RenderApp) else {
            return;
        };
    }
}

type SwfShapeMeshComponent = (
    Entity,
    &'static mut Transform,
    Option<&'static MeshMaterial2d<SwfColorMaterial>>,
    Option<&'static MeshMaterial2d<GradientMaterial>>,
    Option<&'static MeshMaterial2d<BitmapMaterial>>,
    &'static mut SwfShapeMesh,
);

#[derive(Component, Default)]
pub struct SwfShapeMesh {
    transform: Mat4,
}
#[allow(clippy::too_many_arguments)]
pub fn render_swf(
    mut commands: Commands,
    mut swf_movies: ResMut<Assets<SwfMovie>>,
    mut color_materials: ResMut<Assets<SwfColorMaterial>>,
    mut gradient_materials: ResMut<Assets<GradientMaterial>>,
    mut bitmap_materials: ResMut<Assets<BitmapMaterial>>,
    mut query: Query<(&mut FlashAnimation, Entity)>,
    mut entities_material_query: Query<SwfShapeMeshComponent>,
    graphic_query: Query<(Entity, &Children), With<SwfGraphicComponent>>,
) {
    for (mut flash_animation, entity) in query.iter_mut() {
        match flash_animation.status {
            SwfState::Loading => {
                continue;
            }
            SwfState::Ready => {
                flash_animation
                    .shape_mark_entities
                    .clear_current_frame_entity();
                if let Some(swf_movie) = swf_movies.get_mut(flash_animation.swf_movie.id()) {
                    let render_list = swf_movie.root_movie_clip.raw_container().render_list();
                    let parent_clip_transform =
                        swf_movie.root_movie_clip.base().transform().clone();
                    let display_objects = swf_movie
                        .root_movie_clip
                        .raw_container_mut()
                        .display_objects_mut();

                    let mut z_index = 0.000;

                    handler_render_list(
                        entity,
                        &graphic_query,
                        &mut commands,
                        &mut color_materials,
                        &mut gradient_materials,
                        &mut bitmap_materials,
                        &mut entities_material_query,
                        &mut flash_animation.shape_mark_entities,
                        render_list,
                        display_objects,
                        &parent_clip_transform,
                        &mut z_index,
                        BlendType::Trivial(TrivialBlend::Normal),
                    );

                    flash_animation
                        .shape_mark_entities
                        .graphic_entities()
                        .iter()
                        .for_each(|(_, entity)| {
                            commands.entity(*entity).insert(Visibility::Hidden);
                        });
                    flash_animation
                        .shape_mark_entities
                        .current_frame_entities()
                        .iter()
                        .for_each(|shape_mark| {
                            let entity = flash_animation
                                .shape_mark_entities
                                .entity(shape_mark)
                                .unwrap();
                            commands.entity(*entity).insert(Visibility::Inherited);
                        });
                    flash_animation.status = SwfState::Loading;
                }
            }
        }
    }
}

#[allow(clippy::too_many_arguments)]
pub fn handler_render_list(
    parent_entity: Entity,
    graphic_children_entities: &Query<'_, '_, (Entity, &Children), With<SwfGraphicComponent>>,
    commands: &mut Commands,
    color_materials: &mut ResMut<Assets<SwfColorMaterial>>,
    gradient_materials: &mut ResMut<Assets<GradientMaterial>>,
    bitmap_materials: &mut ResMut<Assets<BitmapMaterial>>,
    entities_material_query: &mut Query<'_, '_, SwfShapeMeshComponent>,
    shape_mark_entities: &mut ShapeMarkEntities,
    render_list: Arc<Vec<u128>>,
    display_objects: &mut BTreeMap<u128, DisplayObject>,
    parent_clip_transform: &RuffleTransform,
    z_index: &mut f32,
    blend_type: BlendType,
) {
    for display_object in render_list.iter() {
        if let Some(display_object) = display_objects.get_mut(display_object) {
            match display_object {
                DisplayObject::Graphic(graphic) => {
                    let current_transform = graphic.base().transform();
                    let swf_transform: SwfTransform = RuffleTransform {
                        matrix: parent_clip_transform.matrix * current_transform.matrix,
                        color_transform: parent_clip_transform.color_transform
                            * current_transform.color_transform,
                    }
                    .into();
                    // 记录当前帧生成的graphic实体
                    let mut shape_mark = ShapeMark {
                        graphic_ref_count: 1,
                        depth: graphic.depth(),
                        id: graphic.character_id(),
                    };
                    while shape_mark_entities
                        .current_frame_entities()
                        .iter()
                        .any(|x| *x == shape_mark)
                    {
                        shape_mark.graphic_ref_count += 1;
                    }
                    *z_index += graphic.depth() as f32 / 100.0;
                    if let Some(&existing_entity) = shape_mark_entities.entity(&shape_mark) {
                        // 如果存在缓存实体
                        if let Some((_, graphic_children)) = graphic_children_entities
                            .iter()
                            .find(|(entity, _)| *entity == existing_entity)
                        {
                            graphic_children.iter().for_each(|child| {
                                for (
                                    material_entity,
                                    mut transform,
                                    swf_color_material_handle,
                                    swf_gradient_material_handle,
                                    swf_bitmap_material_handle,
                                    mut swf_shape_mesh,
                                ) in entities_material_query.iter_mut()
                                {
                                    if material_entity == *child {
                                        *z_index += 0.001;
                                        transform.translation.z = *z_index;
                                        if let Some(handle) = swf_color_material_handle {
                                            update_swf_material(
                                                (handle, swf_shape_mesh.as_mut()),
                                                color_materials,
                                                swf_transform.clone(),
                                            );
                                            break;
                                        }
                                        if let Some(handle) = swf_gradient_material_handle {
                                            update_swf_material(
                                                (handle, swf_shape_mesh.as_mut()),
                                                gradient_materials,
                                                swf_transform.clone(),
                                            );
                                            break;
                                        }
                                        if let Some(handle) = swf_bitmap_material_handle {
                                            update_swf_material(
                                                (handle, swf_shape_mesh.as_mut()),
                                                bitmap_materials,
                                                swf_transform.clone(),
                                            );
                                            break;
                                        }
                                    }
                                }
                            });
                        }
                    } else {
                        // 不存在缓存实体
                        let graphic_entity = commands.spawn(SwfGraphicComponent).id();
                        commands.entity(parent_entity).add_child(graphic_entity);
                        shape_mark_entities.add_entities_pool(shape_mark, graphic_entity);
                        graphic.shape_mesh().iter_mut().for_each(|shape| {
                            *z_index += 0.001;
                            let transform =
                                Transform::from_translation(Vec3::new(0.0, 0.0, *z_index));
                            match &shape.draw_type {
                                ShapeDrawType::Color(swf_color_material) => {
                                    spawn_mesh(
                                        commands,
                                        swf_color_material.clone(),
                                        color_materials,
                                        swf_transform.clone(),
                                        graphic_entity,
                                        transform,
                                        shape,
                                        blend_type.clone().into(),
                                    );
                                }
                                ShapeDrawType::Gradient(gradient_material) => {
                                    spawn_mesh(
                                        commands,
                                        gradient_material.clone(),
                                        gradient_materials,
                                        swf_transform.clone(),
                                        graphic_entity,
                                        transform,
                                        shape,
                                        blend_type.clone().into(),
                                    );
                                }
                                ShapeDrawType::Bitmap(bitmap_material) => {
                                    spawn_mesh(
                                        commands,
                                        bitmap_material.clone(),
                                        bitmap_materials,
                                        swf_transform.clone(),
                                        graphic_entity,
                                        transform,
                                        shape,
                                        blend_type.clone().into(),
                                    );
                                }
                            }
                        });
                    }
                    shape_mark_entities.record_current_frame_entity(shape_mark);
                }
                DisplayObject::MovieClip(movie_clip) => {
                    let current_transform = RuffleTransform {
                        matrix: parent_clip_transform.matrix * movie_clip.base().transform().matrix,
                        color_transform: parent_clip_transform.color_transform
                            * movie_clip.base().transform().color_transform,
                    };
                    let blend_type = BlendType::from(movie_clip.blend_mode());

                    handler_render_list(
                        parent_entity,
                        graphic_children_entities,
                        commands,
                        color_materials,
                        gradient_materials,
                        bitmap_materials,
                        entities_material_query,
                        shape_mark_entities,
                        movie_clip.raw_container().render_list(),
                        movie_clip.raw_container_mut().display_objects_mut(),
                        &current_transform,
                        z_index,
                        blend_type,
                    );
                }
            }
        }
    }
}

#[inline]
fn update_swf_material<T: SwfMaterial>(
    exists_material: (&Handle<T>, &mut SwfShapeMesh),
    swf_materials: &mut ResMut<Assets<T>>,
    swf_transform: SwfTransform,
) {
    // 当缓存某实体后该实体在该系统尚未运行完成时会查询不到对应的材质，此时重新生成材质。
    if let Some(swf_material) = swf_materials.get_mut(exists_material.0) {
        let swf_shape_mesh = exists_material.1;
        swf_shape_mesh.transform = swf_transform.world_transform;
        swf_material.update_swf_material(swf_transform);
    }
}

#[inline]
#[allow(clippy::too_many_arguments)]
fn spawn_mesh<T: SwfMaterial>(
    commands: &mut Commands,
    mut swf_material: T,
    swf_materials: &mut ResMut<Assets<T>>,
    swf_transform: SwfTransform,
    parent_entity: Entity,
    transform: Transform,
    shape: &ShapeMesh,
    blend_mode: BlendMode2d,
) {
    swf_material.update_swf_material(swf_transform);
    swf_material.set_blend_mode(blend_mode);
    let aabb_transform = swf_material.world_transform();
    commands.entity(parent_entity).with_children(|parent| {
        parent.spawn((
            Mesh2d(shape.mesh.clone()),
            MeshMaterial2d(swf_materials.add(swf_material)),
            transform,
            SwfShapeMesh {
                transform: aabb_transform,
            },
        ));
    });
}

pub fn calculate_shape_bounds(
    mut commands: Commands,
    meshes: Res<Assets<Mesh>>,
    meshes_without_aabb: Query<(Entity, &Mesh2d, &SwfShapeMesh), Without<NoFrustumCulling>>,
) {
    meshes_without_aabb
        .iter()
        .for_each(|(entity, mesh_handle, swf_shape_mesh)| {
            if let Some(mesh) = meshes.get(&mesh_handle.0) {
                if let Some(mut aabb) = mesh.compute_aabb() {
                    let swf_transform = Mat4::from_cols_array_2d(&[
                        [1.0, 0.0, 0.0, 0.0],
                        [0.0, -1.0, 0.0, 0.0],
                        [0.0, 0.0, 1.0, 0.0],
                        [0.0, 0.0, 0.0, 1.0],
                    ]) * swf_shape_mesh.transform;
                    aabb.center = swf_transform.transform_point3a(aabb.center);
                    commands.entity(entity).try_insert(aabb);
                }
            }
        });
}

================
File: src/render/blend_pipeline.rs
================
use std::marker::PhantomData;

use bevy::{
    asset::{AssetServer, Handle},
    prelude::{FromWorld, Resource, Shader, World},
    render::{
        render_resource::{BindGroupLayout, ShaderRef},
        renderer::RenderDevice,
    },
    sprite::{BlendMode2d, Material2d, Mesh2dPipeline, Mesh2dPipelineKey},
};
use enum_map::Enum;
use ruffle_render::blend::ExtendedBlendMode;

#[derive(Enum, Debug, Copy, Clone)]
pub enum TrivialBlend {
    Normal,
    Add,
    Subtract,
    Screen,
}

#[derive(Enum, Debug, Copy, Clone)]
pub enum ComplexBlend {
    Multiply,   // Can't be trivial, 0 alpha is special case
    Lighten,    // Might be trivial but I can't reproduce the right colors
    Darken,     // Might be trivial but I can't reproduce the right colors
    Difference, // Can't be trivial, relies on abs operation
    Invert,     // May be trivial using a constant? Hard because it's without premultiplied alpha
    Alpha,      // Can't be trivial, requires layer tracking
    Erase,      // Can't be trivial, requires layer tracking
    Overlay,    // Can't be trivial, big math expression
    HardLight,  // Can't be trivial, big math expression
}

#[derive(Clone, Debug)]
#[allow(dead_code)]
pub enum BlendType {
    Trivial(TrivialBlend),
    Complex(ComplexBlend),
}

impl BlendType {
    pub fn from(mode: ExtendedBlendMode) -> BlendType {
        match mode {
            ExtendedBlendMode::Normal => BlendType::Trivial(TrivialBlend::Normal),
            ExtendedBlendMode::Layer => BlendType::Trivial(TrivialBlend::Normal),
            ExtendedBlendMode::Add => BlendType::Trivial(TrivialBlend::Add),
            ExtendedBlendMode::Subtract => BlendType::Trivial(TrivialBlend::Subtract),
            ExtendedBlendMode::Screen => BlendType::Trivial(TrivialBlend::Screen),
            ExtendedBlendMode::Alpha => BlendType::Complex(ComplexBlend::Alpha),
            ExtendedBlendMode::Multiply => BlendType::Complex(ComplexBlend::Multiply),
            ExtendedBlendMode::Lighten => BlendType::Complex(ComplexBlend::Lighten),
            ExtendedBlendMode::Darken => BlendType::Complex(ComplexBlend::Darken),
            ExtendedBlendMode::Difference => BlendType::Complex(ComplexBlend::Difference),
            ExtendedBlendMode::Invert => BlendType::Complex(ComplexBlend::Invert),
            ExtendedBlendMode::Erase => BlendType::Complex(ComplexBlend::Erase),
            ExtendedBlendMode::Overlay => BlendType::Complex(ComplexBlend::Overlay),
            ExtendedBlendMode::HardLight => BlendType::Complex(ComplexBlend::HardLight),
            ExtendedBlendMode::Shader => unreachable!(),
        }
    }
}

impl From<BlendType> for BlendMode2d {
    fn from(value: BlendType) -> Self {
        match value {
            BlendType::Trivial(TrivialBlend::Normal) => BlendMode2d::Normal,
            BlendType::Trivial(TrivialBlend::Add) => BlendMode2d::Add,
            BlendType::Trivial(TrivialBlend::Subtract) => BlendMode2d::Subtract,
            BlendType::Trivial(TrivialBlend::Screen) => BlendMode2d::Screen,
            BlendType::Complex(ComplexBlend::Lighten) => BlendMode2d::Lighten,
            // TODO: Implement complex blend modes
            _ => BlendMode2d::Normal,
        }
    }
}

bitflags::bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    #[repr(transparent)]
    pub struct Mesh2dBlendPipelineKey:u32 {
        const NONE = 0;
        const NORMAL = 1 << 0;
        const ADD = 1 << 1;
        const SUBTRACT = 1 << 2;
        const SCREEN = 1 << 3;
    }
}
#[allow(dead_code)]
pub struct Mesh2dBlendPipeline {
    mesh2d_pipeline: Mesh2dPipeline,
}
impl FromWorld for Mesh2dBlendPipeline {
    fn from_world(world: &mut bevy::prelude::World) -> Self {
        Self {
            mesh2d_pipeline: Mesh2dPipeline::from_world(world),
        }
    }
}

#[derive(Clone, Eq, PartialEq, Hash)]
pub struct Material2dBlendKey<M: Material2d> {
    pub mesh_key: Mesh2dPipelineKey,
    pub blend_key: Mesh2dBlendPipelineKey,
    pub bind_group_data: M::Data,
}

#[derive(Resource)]
pub struct Material2dPipeline<M: Material2d> {
    pub mesh2d_pipeline: Mesh2dPipeline,
    pub material2d_layout: BindGroupLayout,
    pub vertex_shader: Option<Handle<Shader>>,
    pub fragment_shader: Option<Handle<Shader>>,
    marker: PhantomData<M>,
}

impl<M: Material2d> Clone for Material2dPipeline<M> {
    fn clone(&self) -> Self {
        Self {
            mesh2d_pipeline: self.mesh2d_pipeline.clone(),
            material2d_layout: self.material2d_layout.clone(),
            vertex_shader: self.vertex_shader.clone(),
            fragment_shader: self.fragment_shader.clone(),
            marker: PhantomData,
        }
    }
}

impl<M: Material2d> FromWorld for Material2dPipeline<M> {
    fn from_world(world: &mut World) -> Self {
        let asset_server = world.resource::<AssetServer>();
        let render_device = world.resource::<RenderDevice>();
        let material2d_layout = M::bind_group_layout(render_device);

        Material2dPipeline {
            mesh2d_pipeline: world.resource::<Mesh2dPipeline>().clone(),
            material2d_layout,
            vertex_shader: match M::vertex_shader() {
                ShaderRef::Default => None,
                ShaderRef::Handle(handle) => Some(handle),
                ShaderRef::Path(path) => Some(asset_server.load(path)),
            },
            fragment_shader: match M::fragment_shader() {
                ShaderRef::Default => None,
                ShaderRef::Handle(handle) => Some(handle),
                ShaderRef::Path(path) => Some(asset_server.load(path)),
            },
            marker: PhantomData,
        }
    }
}

================
File: src/render/filter/blur.rs
================
use bevy::{
    asset::{Asset, Handle},
    image::Image,
    math::Vec2,
    prelude::{Component, Shader},
    reflect::TypePath,
    render::{
        extract_component::ExtractComponent,
        render_resource::{AsBindGroup, IntoBinding, ShaderType},
    },
    sprite::{AlphaMode2d, Material2d},
};

pub const BLUR_FILTER_SHADER_HANDLE: Handle<Shader> =
    Handle::weak_from_u128(1324534568359871234567890);

#[derive(Component, ExtractComponent, ShaderType, Default, Clone, Copy)]
pub struct BlurFilterUniforms {
    pub direction: Vec2,
    pub full_size: f32,
    pub m: f32,
    pub first_weight: f32,
    pub last_offset: f32,
    pub last_weight: f32,
}

================
File: src/render/filter/mod.rs
================
pub mod blur;

================
File: src/render/material.rs
================
use bevy::{
    asset::{Asset, Handle},
    math::{Mat4, Vec4},
    prelude::Image,
    reflect::TypePath,
    render::render_resource::{AsBindGroup, ShaderType},
    sprite::{AlphaMode2d, BlendMode2d, Material2d},
};
use ruffle_render::{
    shape_utils::GradientType, tessellator::Gradient, transform::Transform as RuffleTransform,
};
use swf::GradientSpread;
use swf_macro::SwfMaterial;

use super::{
    BITMAP_MATERIAL_SHADER_HANDLE, GRADIENT_MATERIAL_SHADER_HANDLE,
    SWF_COLOR_MATERIAL_SHADER_HANDLE,
};

pub trait SwfMaterial: AsBindGroup + TypePath + Asset + Material2d + Clone {
    fn update_swf_material(&mut self, swf_transform: SwfTransform);
    fn world_transform(&self) -> Mat4;
    fn set_blend_mode(&mut self, blend_mode: BlendMode2d);
}

#[derive(AsBindGroup, TypePath, Asset, Debug, Clone, Default, SwfMaterial)]
pub struct GradientMaterial {
    pub blend_mode: BlendMode2d,
    #[uniform(0)]
    pub gradient: GradientUniforms,
    #[texture(1)]
    #[sampler(2)]
    pub texture: Option<Handle<Image>>,
    #[uniform(3)]
    pub texture_transform: Mat4,
    #[uniform(4)]
    pub transform: SwfTransform,
}

impl Material2d for GradientMaterial {
    fn vertex_shader() -> bevy::render::render_resource::ShaderRef {
        GRADIENT_MATERIAL_SHADER_HANDLE.into()
    }
    fn fragment_shader() -> bevy::render::render_resource::ShaderRef {
        GRADIENT_MATERIAL_SHADER_HANDLE.into()
    }
    fn alpha_mode(&self) -> AlphaMode2d {
        AlphaMode2d::Blend
    }
    fn blend_mode(&self) -> BlendMode2d {
        self.blend_mode
    }
}

#[derive(Debug, Clone, Default, ShaderType)]
pub struct GradientUniforms {
    pub focal_point: f32,
    pub interpolation: i32,
    pub shape: i32,
    pub repeat: i32,
}
impl From<Gradient> for GradientUniforms {
    fn from(gradient: Gradient) -> Self {
        Self {
            focal_point: gradient.focal_point.to_f32().clamp(-0.98, 0.98),
            interpolation: (gradient.interpolation == swf::GradientInterpolation::LinearRgb) as i32,
            shape: match gradient.gradient_type {
                GradientType::Linear => 1,
                GradientType::Radial => 2,
                GradientType::Focal => 3,
            },
            repeat: match gradient.repeat_mode {
                GradientSpread::Pad => 1,
                GradientSpread::Reflect => 2,
                GradientSpread::Repeat => 3,
            },
        }
    }
}

#[derive(AsBindGroup, TypePath, Asset, Debug, Clone, Default, SwfMaterial)]
pub struct SwfColorMaterial {
    pub blend_mode: BlendMode2d,
    #[uniform(0)]
    pub transform: SwfTransform,
}

impl Material2d for SwfColorMaterial {
    fn vertex_shader() -> bevy::render::render_resource::ShaderRef {
        SWF_COLOR_MATERIAL_SHADER_HANDLE.into()
    }
    fn fragment_shader() -> bevy::render::render_resource::ShaderRef {
        SWF_COLOR_MATERIAL_SHADER_HANDLE.into()
    }
    fn alpha_mode(&self) -> AlphaMode2d {
        AlphaMode2d::Blend
    }
    fn blend_mode(&self) -> BlendMode2d {
        self.blend_mode
    }
}

#[derive(AsBindGroup, TypePath, Asset, Debug, Clone, Default, SwfMaterial)]
pub struct BitmapMaterial {
    pub blend_mode: BlendMode2d,
    #[texture(0)]
    #[sampler(1)]
    pub texture: Handle<Image>,
    #[uniform(2)]
    pub texture_transform: Mat4,
    #[uniform(3)]
    pub transform: SwfTransform,
}

impl Material2d for BitmapMaterial {
    fn vertex_shader() -> bevy::render::render_resource::ShaderRef {
        BITMAP_MATERIAL_SHADER_HANDLE.into()
    }
    fn fragment_shader() -> bevy::render::render_resource::ShaderRef {
        BITMAP_MATERIAL_SHADER_HANDLE.into()
    }
    fn alpha_mode(&self) -> AlphaMode2d {
        AlphaMode2d::Blend
    }
    fn blend_mode(&self) -> BlendMode2d {
        self.blend_mode
    }
}

#[derive(Debug, Clone, Default, ShaderType)]
pub struct SwfTransform {
    pub world_transform: Mat4,
    mult_color: Vec4,
    add_color: Vec4,
}

impl From<RuffleTransform> for SwfTransform {
    fn from(transform: RuffleTransform) -> Self {
        let matrix = transform.matrix;
        let color_transform = transform.color_transform;
        SwfTransform {
            world_transform: Mat4::from_cols_array_2d(&[
                [matrix.a, matrix.b, 0.0, 0.0],
                [matrix.c, matrix.d, 0.0, 0.0],
                [0.0, 0.0, 1.0, 0.0],
                [
                    matrix.tx.to_pixels() as f32,
                    matrix.ty.to_pixels() as f32,
                    0.0,
                    1.0,
                ],
            ]),
            mult_color: Vec4::from_array(color_transform.mult_rgba_normalized()),
            add_color: Vec4::from_array(color_transform.add_rgba_normalized()),
        }
    }
}

================
File: src/render/node.rs
================
use bevy::render::render_graph::RenderLabel;

#[derive(RenderLabel, Clone, PartialEq, Eq, Debug, Hash)]
pub struct DefineShapeLabel;

#[derive(Default)]
pub struct DefineShapeNode;

// impl Node for DefineShapeNode {
//     fn run<'w>(
//         &self,
//         graph: &mut bevy::render::render_graph::RenderGraphContext,
//         render_context: &mut bevy::render::renderer::RenderContext<'w>,
//         world: &'w bevy::prelude::World,
//     ) -> Result<(), bevy::render::render_graph::NodeRunError> {
//         dbg!("DefineShapeNode::run");
//         Ok(())
//     }
// }

================
File: src/render/shaders/bitmap.wgsl
================
#import bevy_sprite::{mesh2d_functions as mesh_functions, mesh2d_vertex_output::VertexOutput}


struct SwfTransform {
    world_matrix: mat4x4<f32>,
    mult_color: vec4<f32>,
    add_color: vec4<f32>,
}
@group(2) @binding(0) var texture: texture_2d<f32>;
@group(2) @binding(1) var texture_sampler: sampler;
@group(2) @binding(2) var<uniform> texture_transform: mat4x4<f32>;
@group(2) @binding(3) var<uniform> swf_transform: SwfTransform;
override late_saturate: bool = false;

/// 暂时定为固定值
const view_matrix: mat4x4<f32> = mat4x4<f32>(
    vec4<f32>(1.0, 0.0, 0.0, 0.0),
    vec4<f32>(0.0, -1.0, 0.0, 0.0),
    vec4<f32>(0.0, 0.0, 1.0, 0.0),
    vec4<f32>(0.0, 0.0, 0.0, 1.0)
);

struct Vertex {
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3<f32>,
};

@vertex
fn vertex(vertex: Vertex) -> VertexOutput {
    var out: VertexOutput;
    out.uv = (mat3x3<f32>(texture_transform[0].xyz, texture_transform[1].xyz, texture_transform[2].xyz) * vec3<f32>(vertex.position.x, vertex.position.y, 1.0)).xy;
    var position: vec4<f32> = view_matrix * swf_transform.world_matrix * vec4<f32>(vertex.position, 1.0);
    var world_from_local = mesh_functions::get_world_from_local(vertex.instance_index);
    out.world_position = mesh_functions::mesh2d_position_local_to_world(
        world_from_local,
        position
    );
    out.position = mesh_functions::mesh2d_position_world_to_clip(out.world_position);
    return out;
}

@fragment
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
    var color: vec4<f32> = textureSample(texture, texture_sampler, in.uv);

    if color.a > 0.0 {
        color = vec4<f32>(color.rgb / color.a, color.a);
        color = color * swf_transform.mult_color + swf_transform.add_color;
        if !late_saturate {
            color = saturate(color);
        }
        color = vec4<f32>(color.rgb * color.a, color.a);
        if late_saturate {
            color = saturate(color);
        }
    }
    return common__srgb_to_linear(color);
}



/// Converts a color from sRGB to linear color space.
fn common__srgb_to_linear(srgb: vec4<f32>) -> vec4<f32> {
    var rgb: vec3<f32> = srgb.rgb;
    if srgb.a > 0.0 {
        rgb = rgb / srgb.a;
    }
    let a = rgb / 12.92;
    let b = pow((rgb + vec3<f32>(0.055)) / 1.055, vec3<f32>(2.4));
    let c = step(vec3<f32>(0.04045), rgb);
    return vec4<f32>(mix(a, b, c) * srgb.a, srgb.a);
}

================
File: src/render/shaders/color.wgsl
================
#import bevy_sprite::{mesh2d_functions as mesh_functions, mesh2d_vertex_output::VertexOutput}

/// 暂时定为固定值
const view_matrix: mat4x4<f32> = mat4x4<f32>(
    vec4<f32>(1.0, 0.0, 0.0, 0.0),
    vec4<f32>(0.0, -1.0, 0.0, 0.0),
    vec4<f32>(0.0, 0.0, 1.0, 0.0),
    vec4<f32>(0.0, 0.0, 0.0, 1.0)
);

struct SwfTransform {
    world_matrix: mat4x4<f32>,
    mult_color: vec4<f32>,
    add_color: vec4<f32>,
}

@group(2) @binding(0) var<uniform> swf_transform: SwfTransform;

struct Vertex {
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3<f32>,
    @location(4) color: vec4<f32>,
}

@vertex
fn vertex(vertex: Vertex) -> VertexOutput {
    let position: vec4<f32> = view_matrix * swf_transform.world_matrix * vec4<f32>(vertex.position, 1.0);
    var out: VertexOutput;
    var world_from_local = mesh_functions::get_world_from_local(vertex.instance_index);
    out.world_position = mesh_functions::mesh2d_position_local_to_world(
        world_from_local,
        position
    );
    out.position = mesh_functions::mesh2d_position_world_to_clip(out.world_position);
    let color = saturate(vertex.color * swf_transform.mult_color + swf_transform.add_color);
    out.color = vec4<f32>(color.rgb * color.a, color.a);
    return out;
}

@fragment
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
    return in.color;
}

================
File: src/render/shaders/filters/blur.wgsl
================
#import bevy_core_pipeline::fullscreen_vertex_shader::FullscreenVertexOutput

struct BlurFilter {
    // Secretly a vec2<f32> but within alignment rules.
    // One of these is always 0.0, the other is 1.0.
    dir_x: f32,
    dir_y: f32,

    // Full size of the blur kernel.
    full_size: f32,

    // The number of trivially sampleable pixel pairs in the middle.
    m: f32,

    // This is m * 2.0: # of trivially sampleable pixels (not pairs) in the middle.
    m2: f32,

    // The weight of the first sampled pixel - computed as alpha in Rust.
    first_weight: f32,

    // These control the fused sampling of the last pixel pair.
    last_offset: f32,
    last_weight: f32,
}

@group(0) @binding(0) var texture: texture_2d<f32>;
@group(0) @binding(1) var texture_sampler: sampler;

@group(0) @binding(2) var<uniform> filter_args: BlurFilter;


@fragment
fn main_fragment(in: FullscreenVertexOutput) -> @location(0) vec4<f32> {
    in.uv -= in.uv * filter_args.m;
    let direction = vec2<f32>(filter_args.dir_x, filter_args.dir_y);

    var total = vec4<f32>(0.0);

    // The first (potentially fractional) pixel, to the left of the trivial pixel pairs.
    total += textureSample(texture, texture_sampler, in.uv - direction) * filter_args.first_weight;

    var center = vec4<f32>();
    for (var i = 0.5; i < filter_args.m2; i += 2.0) {
        // The center of the kernel is always going to be 1,1 weight pairs.
        // We can just sample between the two pixels and multiply by 2.0.
        // The +0.5 offset is baked right into i. This doesn't affect the
        // iteration (which has a granularity of 2.0, and is open-ended),
        // but saves an addition here in the loop body.
        center += textureSample(texture, texture_sampler, in.uv + direction * i);
    }
    total += center * 2.0;

    // The last pixel pair, the second of which may have fractional weight, sampled together.
    let last_location = in.uv + direction * (filter_args.m2 + filter_args.last_offset);
    total += textureSample(texture, texture_sampler, last_location) * filter_args.last_weight;

    // The sum of every weight is full_size.
    let result = total / filter_args.full_size;

    // This rounding imitates the fixed-point computations of FP, improving emulation accuracy.
    return floor(result * 255.0) / 255.0;
}

================
File: src/render/shaders/gradient.wgsl
================
#import bevy_sprite::{mesh2d_functions as mesh_functions, mesh2d_vertex_output::VertexOutput}

struct Gradient {
    focal_point: f32,
    interpolation: i32,
    shape: i32,
    repeat: i32,
}
struct SwfTransform {
    world_matrix: mat4x4<f32>,
    mult_color: vec4<f32>,
    add_color: vec4<f32>,
}


@group(2) @binding(0) var<uniform> gradient: Gradient;
@group(2) @binding(1) var texture: texture_2d<f32>;
@group(2) @binding(2) var texture_sampler: sampler;
@group(2) @binding(3) var<uniform> texture_transform: mat4x4<f32>;
@group(2) @binding(4) var<uniform> swf_transform: SwfTransform;
/// 暂时定为固定值
const view_matrix: mat4x4<f32> = mat4x4<f32>(
    vec4<f32>(1.0, 0.0, 0.0, 0.0),
    vec4<f32>(0.0, -1.0, 0.0, 0.0),
    vec4<f32>(0.0, 0.0, 1.0, 0.0),
    vec4<f32>(0.0, 0.0, 0.0, 1.0)
);


struct Vertex {
    @builtin(instance_index) instance_index: u32,
    @location(0) position: vec3<f32>,
};


@vertex
fn vertex(vertex: Vertex) -> VertexOutput {
    var out: VertexOutput;
    out.uv = (mat3x3<f32>(texture_transform[0].xyz, texture_transform[1].xyz, texture_transform[2].xyz) * vec3<f32>(vertex.position.x, vertex.position.y, 1.0)).xy;
    let position: vec4<f32> = view_matrix * swf_transform.world_matrix * vec4<f32>(vertex.position, 1.0);
    var world_from_local = mesh_functions::get_world_from_local(vertex.instance_index);
    out.world_position = mesh_functions::mesh2d_position_local_to_world(
        world_from_local,
        position
    );
    out.position = mesh_functions::mesh2d_position_world_to_clip(out.world_position);
    return out;
}

fn find_t(uv: vec2<f32>) -> f32 {
    if gradient.shape == 1 {
        // linear
        return uv.x;
    } if gradient.shape == 2 {
        // radial
        return length(uv * 2.0 - 1.0);
    } else {
        // focal
        let uv = uv * 2.0 - 1.0;
        var d: vec2<f32> = vec2<f32>(gradient.focal_point, 0.0) - uv;
        let l = length(d);
        d = d / l;
        return l / (sqrt(1.0 - gradient.focal_point * gradient.focal_point * d.y * d.y) + gradient.focal_point * d.x);
    }
}

@fragment
fn fragment(in: VertexOutput) -> @location(0) vec4<f32> {
    var t: f32 = find_t(in.uv);
    if gradient.repeat == 1 {
        // Pad
        t = saturate(t);
    } else if gradient.repeat == 2 {
        // Reflect
        if t < 0.0 {
            t = -t;
        }
        if (i32(t) & 1) == 0 {
            t = fract(t);
        } else {
            t = 1.0 - fract(t);
        }
    } else if gradient.repeat == 3 {
        // Repeat
        t = fract(t);
    }
    var color = textureSample(texture, texture_sampler, vec2<f32>(t, 0.0));
    if gradient.interpolation == 0 {
        color = common__srgb_to_linear(color);
    }
    let out = saturate(color * swf_transform.mult_color + swf_transform.add_color);
    let alpha = saturate(out.a);
    return vec4<f32>(out.rgb * alpha, alpha);
}

/// Converts a color from linear to sRGB color space.
fn common__linear_to_srgb(linear_: vec4<f32>) -> vec4<f32> {
    var rgb: vec3<f32> = linear_.rgb;
    if linear_.a > 0.0 {
        rgb = rgb / linear_.a;
    }
    let a = 12.92 * rgb;
    let b = 1.055 * pow(rgb, vec3<f32>(1.0 / 2.4)) - 0.055;
    let c = step(vec3<f32>(0.0031308), rgb);
    return vec4<f32>(mix(a, b, c) * linear_.a, linear_.a);
}

/// Converts a color from sRGB to linear color space.
fn common__srgb_to_linear(srgb: vec4<f32>) -> vec4<f32> {
    var rgb: vec3<f32> = srgb.rgb;
    if srgb.a > 0.0 {
        rgb = rgb / srgb.a;
    }
    let a = rgb / 12.92;
    let b = pow((rgb + vec3<f32>(0.055)) / 1.055, vec3<f32>(2.4));
    let c = step(vec3<f32>(0.04045), rgb);
    return vec4<f32>(mix(a, b, c) * srgb.a, srgb.a);
}

================
File: src/render/tessellator.rs
================
use bevy::log::error;
use indexmap::IndexSet;
use lyon_tessellation::math::Point;
use lyon_tessellation::{
    path::Path, BuffersBuilder, FillOptions, FillTessellator, StrokeOptions, StrokeTessellator,
    VertexBuffers,
};
use lyon_tessellation::{FillVertex, FillVertexConstructor, StrokeVertex, StrokeVertexConstructor};
use ruffle_render::matrix::Matrix;
use ruffle_render::{
    shape_utils::{DistilledShape, DrawCommand, DrawPath, GradientType},
    tessellator::{Bitmap, Draw, DrawType, Gradient, Mesh, Vertex},
};

use crate::swf::library::MovieLibrary;

pub struct ShapeTessellator {
    fill_tess: FillTessellator,
    stroke_tess: StrokeTessellator,
    mesh: Vec<Draw>,
    gradients: IndexSet<Gradient>,
    lyon_mesh: VertexBuffers<Vertex, u32>,
    mask_index_count: Option<u32>,
    is_stroke: bool,
}

impl ShapeTessellator {
    pub fn new() -> Self {
        Self {
            fill_tess: FillTessellator::new(),
            stroke_tess: StrokeTessellator::new(),
            mesh: Vec::new(),
            gradients: IndexSet::new(),
            lyon_mesh: VertexBuffers::new(),
            mask_index_count: None,
            is_stroke: false,
        }
    }

    pub fn tessellate_shape(&mut self, shape: DistilledShape, library: &MovieLibrary) -> Mesh {
        self.mesh = Vec::new();
        self.gradients = IndexSet::new();
        self.lyon_mesh = VertexBuffers::new();

        for path in shape.paths {
            let (fill_style, lyon_path, next_is_stroke) = match &path {
                DrawPath::Fill {
                    style,
                    commands,
                    winding_rule: _,
                } => (*style, ruffle_path_to_lyon_path(commands, true), false),
                DrawPath::Stroke {
                    style,
                    commands,
                    is_closed,
                } => (
                    style.fill_style(),
                    ruffle_path_to_lyon_path(commands, *is_closed),
                    true,
                ),
            };

            let (draw, color, needs_flush) = match fill_style {
                swf::FillStyle::Color(color) => (DrawType::Color, *color, false),
                swf::FillStyle::LinearGradient(gradient) => {
                    let uniform =
                        swf_gradient_to_uniforms(GradientType::Linear, gradient, swf::Fixed8::ZERO);
                    let (gradient_index, _) = self.gradients.insert_full(uniform);

                    (
                        DrawType::Gradient {
                            matrix: swf_to_gl_matrix(gradient.matrix.into()),
                            gradient: gradient_index,
                        },
                        swf::Color::WHITE,
                        true,
                    )
                }
                swf::FillStyle::RadialGradient(gradient) => {
                    let uniform =
                        swf_gradient_to_uniforms(GradientType::Radial, gradient, swf::Fixed8::ZERO);
                    let (gradient_index, _) = self.gradients.insert_full(uniform);
                    (
                        DrawType::Gradient {
                            matrix: swf_to_gl_matrix(gradient.matrix.into()),
                            gradient: gradient_index,
                        },
                        swf::Color::WHITE,
                        true,
                    )
                }
                swf::FillStyle::FocalGradient {
                    gradient,
                    focal_point,
                } => {
                    let uniform =
                        swf_gradient_to_uniforms(GradientType::Focal, gradient, *focal_point);
                    let (gradient_index, _) = self.gradients.insert_full(uniform);
                    (
                        DrawType::Gradient {
                            matrix: swf_to_gl_matrix(gradient.matrix.into()),
                            gradient: gradient_index,
                        },
                        swf::Color::WHITE,
                        true,
                    )
                }
                swf::FillStyle::Bitmap {
                    id,
                    matrix,
                    is_smoothed,
                    is_repeating,
                } => {
                    if let Some(compressed_bitmap) = library.get_bitmap(*id) {
                        let bitmap_size = compressed_bitmap.size();
                        (
                            DrawType::Bitmap(Bitmap {
                                matrix: swf_bitmap_to_gl_matrix(
                                    (*matrix).into(),
                                    bitmap_size.width.into(),
                                    bitmap_size.height.into(),
                                ),
                                bitmap_id: *id,
                                is_smoothed: *is_smoothed,
                                is_repeating: *is_repeating,
                            }),
                            swf::Color::WHITE,
                            true,
                        )
                    } else {
                        continue;
                    }
                }
            };

            if needs_flush || (self.is_stroke && !next_is_stroke) {
                // We flush separate draw calls in these cases:
                // * Non-solid color fills which require their own shader.
                // * Strokes followed by fills, because strokes need to be omitted
                //   when using this shape as a mask.
                self.flush_draw(DrawType::Color);
            } else if !self.is_stroke && next_is_stroke {
                // Bake solid color fills followed by strokes into a single draw call, and adjust
                // the index count to omit the strokes when rendering this shape as a mask.
                assert!(self.mask_index_count.is_none());
                self.mask_index_count = Some(self.lyon_mesh.indices.len() as u32);
            }
            self.is_stroke = next_is_stroke;

            let mut buffers_builder =
                BuffersBuilder::new(&mut self.lyon_mesh, RuffleVertexCtor { color });
            let result = match path {
                DrawPath::Fill { winding_rule, .. } => self.fill_tess.tessellate_path(
                    &lyon_path,
                    &FillOptions::default().with_fill_rule(winding_rule.into()),
                    &mut buffers_builder,
                ),
                DrawPath::Stroke { style, .. } => {
                    let width = (style.width().to_pixels() as f32).max(1.0);
                    let mut stroke_options = StrokeOptions::default()
                        .with_line_width(width)
                        .with_start_cap(match style.start_cap() {
                            swf::LineCapStyle::None => lyon_tessellation::LineCap::Butt,
                            swf::LineCapStyle::Round => lyon_tessellation::LineCap::Round,
                            swf::LineCapStyle::Square => lyon_tessellation::LineCap::Square,
                        })
                        .with_end_cap(match style.end_cap() {
                            swf::LineCapStyle::None => lyon_tessellation::LineCap::Butt,
                            swf::LineCapStyle::Round => lyon_tessellation::LineCap::Round,
                            swf::LineCapStyle::Square => lyon_tessellation::LineCap::Square,
                        });

                    let line_join = match style.join_style() {
                        swf::LineJoinStyle::Round => lyon_tessellation::LineJoin::Round,
                        swf::LineJoinStyle::Bevel => lyon_tessellation::LineJoin::Bevel,
                        swf::LineJoinStyle::Miter(limit) => {
                            // Avoid lyon assert with small miter limits.
                            let limit = limit.to_f32();
                            if limit >= StrokeOptions::MINIMUM_MITER_LIMIT {
                                stroke_options = stroke_options.with_miter_limit(limit);
                                lyon_tessellation::LineJoin::MiterClip
                            } else {
                                lyon_tessellation::LineJoin::Bevel
                            }
                        }
                    };
                    stroke_options = stroke_options.with_line_join(line_join);
                    self.stroke_tess.tessellate_path(
                        &lyon_path,
                        &stroke_options,
                        &mut buffers_builder,
                    )
                }
            };
            match result {
                Ok(_) => {
                    if needs_flush {
                        // Non-solid color fills are isolated draw calls; flush immediately.
                        self.flush_draw(draw);
                    }
                }
                Err(e) => {
                    // This may simply be a degenerate path.
                    error!("Tessellation failure: {:?}", e);
                }
            }
        }

        // Flush the final pending draw.
        self.flush_draw(DrawType::Color);

        self.lyon_mesh = VertexBuffers::new();
        Mesh {
            draws: std::mem::take(&mut self.mesh),
            gradients: std::mem::take(&mut self.gradients).into_iter().collect(),
        }
    }

    fn flush_draw(&mut self, draw: DrawType) {
        if self.lyon_mesh.vertices.is_empty() || self.lyon_mesh.indices.len() < 3 {
            // Ignore degenerate fills
            self.lyon_mesh = VertexBuffers::new();
            self.mask_index_count = None;
            return;
        }
        let draw_mesh = std::mem::replace(&mut self.lyon_mesh, VertexBuffers::new());
        self.mesh.push(Draw {
            draw_type: draw,
            mask_index_count: self
                .mask_index_count
                .unwrap_or(draw_mesh.indices.len() as u32),
            vertices: draw_mesh.vertices,
            indices: draw_mesh.indices,
        });
        self.mask_index_count = None;
    }
}

fn ruffle_path_to_lyon_path(commands: &[DrawCommand], is_closed: bool) -> Path {
    fn point(point: swf::Point<swf::Twips>) -> Point {
        Point::new(point.x.to_pixels() as f32, point.y.to_pixels() as f32)
    }

    let mut builder = Path::builder();
    let mut cursor = Some(swf::Point::ZERO);
    for command in commands {
        match command {
            DrawCommand::MoveTo(move_to) => {
                if cursor.is_none() {
                    builder.end(false);
                }
                cursor = Some(*move_to);
            }
            DrawCommand::LineTo(line_to) => {
                if let Some(cursor) = cursor.take() {
                    builder.begin(point(cursor));
                }
                builder.line_to(point(*line_to));
            }
            DrawCommand::QuadraticCurveTo { control, anchor } => {
                if let Some(cursor) = cursor.take() {
                    builder.begin(point(cursor));
                }
                builder.quadratic_bezier_to(point(*control), point(*anchor));
            }
            DrawCommand::CubicCurveTo {
                control_a,
                control_b,
                anchor,
            } => {
                if let Some(cursor) = cursor.take() {
                    builder.begin(point(cursor));
                }
                builder.cubic_bezier_to(point(*control_a), point(*control_b), point(*anchor));
            }
        }
    }

    if cursor.is_none() {
        if is_closed {
            builder.close();
        } else {
            builder.end(false);
        }
    }

    builder.build()
}

#[allow(clippy::many_single_char_names)]
fn swf_to_gl_matrix(m: Matrix) -> [[f32; 3]; 3] {
    let tx = m.tx.get() as f32;
    let ty = m.ty.get() as f32;
    let det = m.a * m.d - m.c * m.b;
    let mut a = m.d / det;
    let mut b = -m.c / det;
    let mut c = -(tx * m.d - m.c * ty) / det;
    let mut d = -m.b / det;
    let mut e = m.a / det;
    let mut f = (tx * m.b - m.a * ty) / det;

    a *= 20.0 / 32768.0;
    b *= 20.0 / 32768.0;
    d *= 20.0 / 32768.0;
    e *= 20.0 / 32768.0;

    c /= 32768.0;
    f /= 32768.0;
    c += 0.5;
    f += 0.5;
    [[a, d, 0.0], [b, e, 0.0], [c, f, 1.0]]
}

#[allow(clippy::many_single_char_names)]
fn swf_bitmap_to_gl_matrix(m: Matrix, bitmap_width: u32, bitmap_height: u32) -> [[f32; 3]; 3] {
    let bitmap_width = bitmap_width as f32;
    let bitmap_height = bitmap_height as f32;

    let tx = m.tx.get() as f32;
    let ty = m.ty.get() as f32;
    let det = m.a * m.d - m.c * m.b;
    let mut a = m.d / det;
    let mut b = -m.c / det;
    let mut c = -(tx * m.d - m.c * ty) / det;
    let mut d = -m.b / det;
    let mut e = m.a / det;
    let mut f = (tx * m.b - m.a * ty) / det;

    a *= 20.0 / bitmap_width;
    b *= 20.0 / bitmap_width;
    d *= 20.0 / bitmap_height;
    e *= 20.0 / bitmap_height;

    c /= bitmap_width;
    f /= bitmap_height;

    [[a, d, 0.0], [b, e, 0.0], [c, f, 1.0]]
}

/// Converts a gradient to the uniforms used by the shader.
fn swf_gradient_to_uniforms(
    gradient_type: GradientType,
    gradient: &swf::Gradient,
    focal_point: swf::Fixed8,
) -> Gradient {
    Gradient {
        records: gradient.records.clone(),
        gradient_type,
        repeat_mode: gradient.spread,
        focal_point,
        interpolation: gradient.interpolation,
    }
}

struct RuffleVertexCtor {
    color: swf::Color,
}

impl FillVertexConstructor<Vertex> for RuffleVertexCtor {
    fn new_vertex(&mut self, vertex: FillVertex) -> Vertex {
        Vertex {
            x: vertex.position().x,
            y: vertex.position().y,
            color: self.color,
        }
    }
}

impl StrokeVertexConstructor<Vertex> for RuffleVertexCtor {
    fn new_vertex(&mut self, vertex: StrokeVertex) -> Vertex {
        Vertex {
            x: vertex.position().x,
            y: vertex.position().y,
            color: self.color,
        }
    }
}

================
File: src/swf.rs
================
pub(crate) mod characters;
mod container;
pub mod display_object;
pub(crate) mod library;
pub(crate) mod tag_utils;

================
File: src/swf/characters.rs
================
use ruffle_render::bitmap::BitmapSize;
use swf::DefineBitsLossless;

use super::display_object::{graphic::Graphic, movie_clip::MovieClip};

#[derive(Clone)]
pub enum Character {
    MovieClip(MovieClip),
    Graphic(Graphic),
    Bitmap(CompressedBitmap),
}

#[derive(Clone, Debug)]
pub enum CompressedBitmap {
    Jpeg {
        data: Vec<u8>,
        alpha: Option<Vec<u8>>,
        width: u16,
        height: u16,
    },
    Lossless(DefineBitsLossless<'static>),
}

impl CompressedBitmap {
    pub fn size(&self) -> BitmapSize {
        match self {
            CompressedBitmap::Jpeg { width, height, .. } => BitmapSize {
                width: *width,
                height: *height,
            },
            CompressedBitmap::Lossless(DefineBitsLossless { width, height, .. }) => BitmapSize {
                width: *width,
                height: *height,
            },
        }
    }

    pub fn decode(&self) -> Result<ruffle_render::bitmap::Bitmap, ruffle_render::error::Error> {
        match self {
            CompressedBitmap::Jpeg { data, alpha, .. } => {
                ruffle_render::utils::decode_define_bits_jpeg(data, alpha.as_deref())
            }
            CompressedBitmap::Lossless(define_bits_lossless) => {
                ruffle_render::utils::decode_define_bits_lossless(define_bits_lossless)
            }
        }
    }
}

================
File: src/swf/container.rs
================
use std::{collections::BTreeMap, ops::Bound, sync::Arc};

use swf::Depth;
use uuid::Uuid;

use super::display_object::DisplayObject;

type DisplayId = u128;

#[derive(Clone)]
pub struct ChildContainer {
    render_list: Arc<Vec<DisplayId>>,
    depth_list: BTreeMap<Depth, DisplayId>,

    display_objects: BTreeMap<DisplayId, DisplayObject>,
}

impl Default for ChildContainer {
    fn default() -> Self {
        Self::new()
    }
}

impl ChildContainer {
    pub fn new() -> Self {
        Self {
            render_list: Arc::new(Vec::new()),
            depth_list: BTreeMap::new(),
            display_objects: BTreeMap::new(),
        }
    }

    pub fn render_list_len(&self) -> usize {
        self.render_list.len()
    }

    pub fn render_list(&self) -> Arc<Vec<DisplayId>> {
        self.render_list.clone()
    }

    pub fn render_list_mut(&mut self) -> &mut Vec<DisplayId> {
        Arc::make_mut(&mut self.render_list)
    }

    pub fn first_child(&self) -> Option<&DisplayObject> {
        self.render_list
            .first()
            .and_then(|id| self.display_objects.get(id))
    }

    pub fn child_by_depth(&mut self, depth: Depth) -> Option<&mut DisplayObject> {
        let display_object_id = self.depth_list.get(&depth);
        if let Some(display_object_id) = display_object_id {
            let display_object = self.display_objects.get_mut(display_object_id);
            display_object
        } else {
            None
        }
    }

    pub fn display_objects(&self) -> &BTreeMap<DisplayId, DisplayObject> {
        &self.display_objects
    }

    pub fn display_objects_mut(&mut self) -> &mut BTreeMap<DisplayId, DisplayObject> {
        &mut self.display_objects
    }

    fn insert_child_into_depth_list(
        &mut self,
        depth: Depth,
        child: DisplayObject,
    ) -> (Option<DisplayId>, DisplayId) {
        let display_object_id = Uuid::new_v4().to_u128_le();
        self.display_objects.insert(display_object_id, child);
        let prev_child = self.depth_list.insert(depth, display_object_id);
        (prev_child, display_object_id)
    }

    fn insert_id(&mut self, id: usize, child: DisplayId) {
        self.render_list_mut().insert(id, child);
    }

    fn push_id(&mut self, child: DisplayId) {
        self.render_list_mut().push(child);
    }

    pub fn remove_child_from_depth_list(&mut self, child: Depth) -> Option<DisplayId> {
        if let Some(remove) = self.depth_list.remove(&child) {
            self.display_objects.remove(&remove);
            Some(remove)
        } else {
            None
        }
    }

    pub fn remove_child(&mut self, child: Depth) {
        let display_id = self.remove_child_from_depth_list(child);
        if let Some(display_id) = display_id {
            Self::remove_child_from_render_list(self, display_id);
        }
    }

    fn remove_child_from_render_list(container: &mut ChildContainer, child: DisplayId) -> bool {
        let render_list_position: Option<usize> =
            container.render_list.iter().position(|x| *x == child);
        if let Some(position) = render_list_position {
            container.render_list_mut().remove(position);
            true
        } else {
            false
        }
    }

    pub fn replace_at_depth(&mut self, depth: Depth, child: DisplayObject) {
        let (prev_child, child_display_object_id) = self.insert_child_into_depth_list(depth, child);
        if let Some(prev_child) = prev_child {
            if let Some(position) = self.render_list.iter().position(|x| *x == prev_child) {
                self.insert_id(position + 1, child_display_object_id);
            }
        } else {
            let above = self
                .depth_list
                .range((Bound::Excluded(depth), Bound::Unbounded))
                .map(|(_, v)| *v)
                .next();
            if let Some(above_child) = above {
                if let Some(position) = self.render_list.iter().position(|x| *x == above_child) {
                    self.insert_id(position, child_display_object_id);
                } else {
                    self.push_id(child_display_object_id)
                }
            } else {
                self.push_id(child_display_object_id)
            }
        }
    }
}

================
File: src/swf/display_object.rs
================
pub(crate) mod graphic;
pub mod movie_clip;
use std::sync::Arc;

use bitflags::bitflags;
use graphic::Graphic;
use movie_clip::MovieClip;
use ruffle_macros::enum_trait_object;
use ruffle_render::{
    backend::RenderBackend,
    bitmap::{BitmapHandle, BitmapInfo},
    blend::ExtendedBlendMode,
    filters::Filter,
    matrix::Matrix,
    transform::Transform,
};
use swf::{CharacterId, Color, ColorTransform, Depth, Point, Rectangle, Twips};

use super::{library::MovieLibrary, tag_utils::SwfMovie};

bitflags! {
    /// Bit flags used by `DisplayObject`.
    #[derive(Clone, Copy)]
    struct DisplayObjectFlags: u16 {
        /// If this object is visible (`_visible` property).
        const VISIBLE                  = 1 << 0;

        /// Whether this object is a "root", the top-most display object of a loaded SWF or Bitmap.
        /// Used by `MovieClip.getBytesLoaded` in AVM1 and `DisplayObject.root` in AVM2.
        const IS_ROOT                  = 1 << 1;

        /// Whether this object will be cached to bitmap.
        const CACHE_AS_BITMAP          = 1 << 2;

        /// If this object has already had `invalidate_cached_bitmap` called this frame
        const CACHE_INVALIDATED        = 1 << 3;
    }
}
#[derive(Clone, Debug, Default)]
#[allow(dead_code)]
pub struct BitmapCache {
    /// The `Matrix.a` value that was last used with this cache
    matrix_a: f32,
    /// The `Matrix.b` value that was last used with this cache
    matrix_b: f32,
    /// The `Matrix.c` value that was last used with this cache
    matrix_c: f32,
    /// The `Matrix.d` value that was last used with this cache
    matrix_d: f32,

    /// The width of the original bitmap, pre-filters
    source_width: u16,

    /// The height of the original bitmap, pre-filters
    source_height: u16,

    /// The offset used to draw the final bitmap (i.e. if a filter increases the size)
    draw_offset: Point<i32>,

    /// The current contents of the cache, if any. Values are post-filters.
    bitmap: Option<BitmapInfo>,

    /// Whether we warned that this bitmap was too large to be cached
    warned_for_oversize: bool,
}

#[allow(dead_code)]
impl BitmapCache {
    /// Forcefully make this BitmapCache invalid and require regeneration.
    /// This should be used for changes that aren't automatically detected, such as children.
    pub fn make_dirty(&mut self) {
        // Setting the old transform to something invalid is a cheap way of making it invalid,
        // without reserving an extra field for.
        self.matrix_a = f32::NAN;
    }

    fn is_dirty(&self, other: &Matrix, source_width: u16, source_height: u16) -> bool {
        self.matrix_a != other.a
            || self.matrix_b != other.b
            || self.matrix_c != other.c
            || self.matrix_d != other.d
            || self.source_width != source_width
            || self.source_height != source_height
            || self.bitmap.is_none()
    }

    /// Clears any dirtiness and ensure there's an appropriately sized texture allocated
    #[allow(clippy::too_many_arguments)]
    fn update(
        &mut self,
        renderer: &mut dyn RenderBackend,
        matrix: Matrix,
        source_width: u16,
        source_height: u16,
        actual_width: u16,
        actual_height: u16,
        draw_offset: Point<i32>,
        swf_version: u8,
    ) {
        self.matrix_a = matrix.a;
        self.matrix_b = matrix.b;
        self.matrix_c = matrix.c;
        self.matrix_d = matrix.d;
        self.source_width = source_width;
        self.source_height = source_height;
        self.draw_offset = draw_offset;
        if let Some(current) = &mut self.bitmap {
            if current.width == actual_width && current.height == actual_height {
                return; // No need to resize it
            }
        }
        let acceptable_size = if swf_version > 9 {
            let total = actual_width as u32 * actual_height as u32;
            actual_width < 8191 && actual_height < 8191 && total < 16777215
        } else {
            actual_width < 2880 && actual_height < 2880
        };
        if renderer.is_offscreen_supported()
            && actual_width > 0
            && actual_height > 0
            && acceptable_size
        {
            let handle = renderer.create_empty_texture(actual_width as u32, actual_height as u32);
            self.bitmap = handle.ok().map(|handle| BitmapInfo {
                width: actual_width,
                height: actual_height,
                handle,
            });
        } else {
            self.bitmap = None;
        }
    }

    /// Explicitly clears the cached value and drops any resources.
    /// This should only be used in situations where you can't render to the cache and it needs to be
    /// temporarily disabled.
    fn clear(&mut self) {
        self.bitmap = None;
    }

    fn handle(&self) -> Option<BitmapHandle> {
        self.bitmap.as_ref().map(|b| b.handle.clone())
    }
}

#[derive(Clone)]
pub struct DisplayObjectBase {
    place_frame: u16,
    depth: Depth,
    clip_depth: Depth,
    name: Option<String>,
    transform: Transform,
    blend_mode: ExtendedBlendMode,
    flags: DisplayObjectFlags,
    #[allow(unused)]
    scaling_grid: Rectangle<Twips>,
    opaque_background: Option<Color>,
    filters: Vec<Filter>,
    cache: Option<BitmapCache>,
}
unsafe impl Send for DisplayObjectBase {}
unsafe impl Sync for DisplayObjectBase {}

impl Default for DisplayObjectBase {
    fn default() -> Self {
        Self {
            place_frame: Default::default(),
            depth: Default::default(),
            clip_depth: Default::default(),
            name: None,
            transform: Default::default(),
            blend_mode: Default::default(),
            opaque_background: Default::default(),
            flags: DisplayObjectFlags::VISIBLE,
            filters: Default::default(),
            cache: None,
            scaling_grid: Default::default(),
        }
    }
}
impl DisplayObjectBase {
    pub fn transform(&self) -> &Transform {
        &self.transform
    }

    fn blend_mode(&self) -> ExtendedBlendMode {
        self.blend_mode
    }

    pub fn name(&self) -> Option<&str> {
        self.name.as_deref()
    }

    pub fn matrix(&self) -> &Matrix {
        &self.transform.matrix
    }

    fn filters(&self) -> Vec<Filter> {
        self.filters.clone()
    }

    #[allow(unused)]
    fn clip_depth(&self) -> Depth {
        self.clip_depth
    }

    fn visible(&self) -> bool {
        self.flags.contains(DisplayObjectFlags::VISIBLE)
    }

    pub fn set_name(&mut self, name: Option<String>) {
        self.name = name;
    }

    pub fn set_transform(&mut self, transform: Transform) {
        self.transform = transform;
    }
    pub fn set_root(&mut self) {
        self.flags.set(DisplayObjectFlags::IS_ROOT, true);
    }

    fn set_depth(&mut self, depth: Depth) {
        self.depth = depth;
    }

    fn set_matrix(&mut self, matrix: Matrix) {
        self.transform.matrix = matrix;
    }

    pub fn set_color_transform(&mut self, color_transform: ColorTransform) {
        self.transform.color_transform = color_transform;
    }

    fn set_bitmap_cached_preference(&mut self, value: bool) {
        self.flags.set(DisplayObjectFlags::CACHE_AS_BITMAP, value);
        self.recheck_cache_as_bitmap();
    }

    fn is_bitmap_cached_preference(&self) -> bool {
        self.flags.contains(DisplayObjectFlags::CACHE_AS_BITMAP)
    }

    fn recheck_cache_as_bitmap(&mut self) {
        let should_cache = self.is_bitmap_cached_preference() || !self.filters.is_empty();
        if should_cache && self.cache.is_none() {
            self.cache = Some(Default::default());
        } else if !should_cache && self.cache.is_some() {
            self.cache = None;
        }
    }
    fn set_blend_mode(&mut self, value: ExtendedBlendMode) -> bool {
        let changed = self.blend_mode != value;
        self.blend_mode = value;
        changed
    }
    fn set_filters(&mut self, filters: Vec<Filter>) -> bool {
        if filters != self.filters {
            self.filters = filters;
            self.recheck_cache_as_bitmap();
            true
        } else {
            false
        }
    }

    fn set_visible(&mut self, visible: bool) -> bool {
        let changed = self.visible() != visible;
        self.flags.set(DisplayObjectFlags::VISIBLE, visible);
        changed
    }

    fn set_opaque_background(&mut self, value: Option<Color>) -> bool {
        let value = value.map(|mut color| {
            color.a = 255;
            color
        });
        let changed = self.opaque_background != value;
        self.opaque_background = value;
        changed
    }

    fn set_place_frame(&mut self, frame: u16) {
        self.place_frame = frame;
    }

    fn invalidate_cached_bitmap(&mut self) -> bool {
        if self.flags.contains(DisplayObjectFlags::CACHE_INVALIDATED) {
            return false;
        }
        if let Some(cache) = &mut self.cache {
            cache.make_dirty();
        }
        self.flags.insert(DisplayObjectFlags::CACHE_INVALIDATED);
        true
    }

    pub fn clear_invalidate_flag(&mut self) {
        self.flags.remove(DisplayObjectFlags::CACHE_INVALIDATED);
    }

    fn set_clip_depth(&mut self, depth: Depth) {
        self.clip_depth = depth;
    }

    fn is_root(&self) -> bool {
        self.flags.contains(DisplayObjectFlags::IS_ROOT)
    }

    #[allow(unused)]
    fn bitmap_cache_mut(&mut self) -> Option<&mut BitmapCache> {
        self.cache.as_mut()
    }
}

#[enum_trait_object(
    #[derive(Clone)]
    pub enum DisplayObject {
        MovieClip(MovieClip),
        Graphic(Graphic),
    }
)]

pub trait TDisplayObject: Clone + Into<DisplayObject> {
    fn base(&self) -> &DisplayObjectBase;
    fn base_mut(&mut self) -> &mut DisplayObjectBase;
    fn movie(&self) -> Arc<SwfMovie>;
    fn character_id(&self) -> CharacterId;
    fn depth(&self) -> Depth {
        self.base().depth
    }

    fn place_frame(&self) -> u16 {
        self.base().place_frame
    }

    fn is_bitmap_cached(&self) -> bool {
        self.base().cache.is_some()
    }
    fn is_root(&self) -> bool {
        self.base().is_root()
    }
    fn filters(&self) -> Vec<Filter> {
        self.base().filters()
    }
    fn opaque_background(&self) -> Option<Color> {
        self.base().opaque_background
    }

    fn allow_as_mask(&self) -> bool {
        true
    }
    fn visible(&self) -> bool {
        self.base().visible()
    }
    fn name(&self) -> Option<&str> {
        self.base().name()
    }

    fn blend_mode(&self) -> ExtendedBlendMode {
        self.base().blend_mode()
    }

    fn set_name(&mut self, name: Option<String>) {
        self.base_mut().set_name(name);
    }
    fn set_clip_depth(&mut self, depth: Depth) {
        self.base_mut().set_clip_depth(depth);
    }
    fn set_matrix(&mut self, matrix: Matrix) {
        self.base_mut().set_matrix(matrix);
    }
    fn set_color_transform(&mut self, color_transform: ColorTransform) {
        self.base_mut().set_color_transform(color_transform);
    }
    fn set_bitmap_cached_preference(&mut self, value: bool) {
        self.base_mut().set_bitmap_cached_preference(value);
    }
    fn set_blend_mode(&mut self, blend_mode: ExtendedBlendMode) {
        self.base_mut().set_blend_mode(blend_mode);
    }
    fn set_opaque_background(&mut self, value: Option<Color>) {
        if self.base_mut().set_opaque_background(value) {
            self.invalidate_cached_bitmap();
        }
    }
    fn set_filters(&mut self, filters: Vec<Filter>) {
        self.base_mut().set_filters(filters);
    }
    fn set_visible(&mut self, visible: bool) {
        self.base_mut().set_visible(visible);
    }
    fn set_place_frame(&mut self, frame: u16) {
        self.base_mut().set_place_frame(frame);
    }
    fn set_depth(&mut self, depth: Depth) {
        self.base_mut().set_depth(depth);
    }
    fn set_root(&mut self) {
        self.base_mut().set_root();
    }

    fn invalidate_cached_bitmap(&mut self) {
        if self.base_mut().invalidate_cached_bitmap() {
            // Don't inform ancestors if we've already done so this frame
        }
    }

    fn set_default_instance_name(&mut self, library: &mut MovieLibrary) {
        if self.base().name.is_none() {
            let name = format!("instance{}", library.instance_count);
            self.set_name(Some(name));
            library.instance_count = library.instance_count.wrapping_add(1);
        }
    }

    fn post_instantiation(&mut self, library: &mut MovieLibrary) {
        self.set_default_instance_name(library);
    }

    fn enter_frame(&mut self, _library: &mut MovieLibrary) {}

    fn replace_with(&mut self, _id: CharacterId, _library: &mut MovieLibrary) {}

    fn as_movie(&mut self) -> Option<MovieClip> {
        None
    }

    fn apply_place_object(&mut self, place_object: &swf::PlaceObject, swf_version: u8) {
        if let Some(matrix) = place_object.matrix {
            self.set_matrix(matrix.into());
        }
        if let Some(color_transform) = &place_object.color_transform {
            self.set_color_transform(*color_transform);
        }
        if let Some(is_bitmap_cached) = place_object.is_bitmap_cached {
            self.set_bitmap_cached_preference(is_bitmap_cached);
        }
        if let Some(blend_mode) = place_object.blend_mode {
            self.set_blend_mode(blend_mode.into());
        }
        if swf_version >= 11 {
            if let Some(visible) = place_object.is_visible {
                self.set_visible(visible);
            }
            if let Some(mut color) = place_object.background_color {
                let color = if color.a > 0 {
                    color.a = 255;
                    Some(color)
                } else {
                    None
                };
                self.set_opaque_background(color);
            }
        }
        if let Some(filters) = &place_object.filters {
            self.set_filters(filters.iter().map(Filter::from).collect())
        }
    }
}

================
File: src/swf/display_object/graphic.rs
================
use std::sync::Arc;

use bevy::log::error;
use swf::{CharacterId, Rectangle, Shape, Twips};

use crate::{
    plugin::ShapeMesh,
    swf::{library::MovieLibrary, tag_utils::SwfMovie},
};

use super::{DisplayObjectBase, TDisplayObject};

#[derive(Clone)]
pub struct Graphic {
    pub id: CharacterId,
    pub shape: Shape,
    pub bounds: Rectangle<Twips>,
    base: DisplayObjectBase,
    swf_movie: Arc<SwfMovie>,
    shape_mesh: Vec<ShapeMesh>,
}

impl Graphic {
    pub fn from_swf_tag(shape: Shape, swf_movie: Arc<SwfMovie>) -> Self {
        Self {
            id: shape.id,
            bounds: shape.shape_bounds.clone(),
            shape,
            base: DisplayObjectBase::default(),
            swf_movie,
            shape_mesh: Vec::new(),
        }
    }

    pub fn add_shape_mesh(&mut self, shape_mesh: ShapeMesh) {
        self.shape_mesh.push(shape_mesh);
    }

    pub fn shape_mesh(&mut self) -> &mut Vec<ShapeMesh> {
        &mut self.shape_mesh
    }
}

impl TDisplayObject for Graphic {
    fn base_mut(&mut self) -> &mut DisplayObjectBase {
        &mut self.base
    }

    fn base(&self) -> &DisplayObjectBase {
        &self.base
    }

    fn character_id(&self) -> CharacterId {
        self.id
    }

    fn movie(&self) -> Arc<SwfMovie> {
        self.swf_movie.clone()
    }

    fn replace_with(&mut self, id: CharacterId, library: &mut MovieLibrary) {
        if let Some(new_graphic) = library.get_graphic(id) {
            self.id = new_graphic.id;
            self.shape = new_graphic.shape;
            self.bounds = new_graphic.bounds;
            self.shape_mesh = new_graphic.shape_mesh;
        } else {
            error!("PlaceObject: expected Graphic at character ID {}", id);
        }
    }
}

================
File: src/swf/display_object/movie_clip.rs
================
use std::{cmp::max, collections::HashMap, sync::Arc};

use anyhow::anyhow;
use bevy::log::{error, info};
use bitflags::bitflags;

use ruffle_render::matrix::Matrix;
use smallvec::SmallVec;
use swf::{
    extensions::ReadSwfExt, read::Reader, CharacterId, Color, Depth, PlaceObjectAction, SwfStr,
    TagCode,
};

use crate::swf::{
    characters::{Character, CompressedBitmap},
    container::ChildContainer,
    library::MovieLibrary,
    tag_utils::{self, ControlFlow, Error, SwfMovie, SwfSlice, SwfStream},
};

use super::{graphic::Graphic, DisplayObject, DisplayObjectBase, TDisplayObject};

type FrameNumber = u16;
type SwfVersion = u8;
/// Indication of what frame `run_frame` should jump to next.
#[derive(PartialEq, Eq)]
pub enum NextFrame {
    /// Construct and run the next frame in the clip.
    Next,

    /// Jump to the first frame in the clip.
    First,

    /// Do not construct or run any frames.
    Same,
}
bitflags! {
    /// Boolean state flags used by `MovieClip`.
    #[derive(Clone, Copy)]
    struct MovieClipFlags: u8 {
        /// Whether this `MovieClip` is playing or stopped.
        const PLAYING                 = 1 << 0;

        const STOP                     = 1 << 1;

        /// Whether this `MovieClip` has been post-instantiated yet.
        const POST_INSTANTIATED        = 1 << 2;
    }
}
#[derive(Clone)]
pub struct MovieClip {
    base: DisplayObjectBase,
    swf: SwfSlice,
    pub id: CharacterId,
    pub current_frame: FrameNumber,
    pub total_frames: FrameNumber,
    frame_labels: Vec<(FrameNumber, String)>,
    container: ChildContainer,
    flags: MovieClipFlags,
    tag_stream_pos: u64,
    queued_tags: HashMap<Depth, QueuedTagList>,
}
impl Default for MovieClip {
    fn default() -> Self {
        Self {
            base: Default::default(),
            swf: Default::default(),
            id: Default::default(),
            current_frame: Default::default(),
            total_frames: Default::default(),
            frame_labels: Default::default(),
            container: Default::default(),
            flags: MovieClipFlags::PLAYING,
            tag_stream_pos: Default::default(),
            queued_tags: Default::default(),
        }
    }
}
impl MovieClip {
    pub fn new(movie: Arc<SwfMovie>) -> Self {
        Self {
            base: DisplayObjectBase::default(),
            id: Default::default(),
            current_frame: 0,
            total_frames: movie.num_frames(),
            frame_labels: Default::default(),
            swf: SwfSlice::empty(movie),
            container: ChildContainer::new(),
            flags: MovieClipFlags::PLAYING,
            tag_stream_pos: 0,
            queued_tags: HashMap::new(),
        }
    }
    pub fn new_with_data(id: CharacterId, total_frames: FrameNumber, swf: SwfSlice) -> Self {
        Self {
            base: DisplayObjectBase::default(),
            id,
            total_frames,
            current_frame: 0,
            frame_labels: Default::default(),
            swf,
            container: ChildContainer::new(),
            flags: MovieClipFlags::PLAYING,
            tag_stream_pos: 0,
            queued_tags: HashMap::new(),
        }
    }

    pub fn raw_container(&self) -> &ChildContainer {
        &self.container
    }

    pub fn raw_container_mut(&mut self) -> &mut ChildContainer {
        &mut self.container
    }

    pub fn replace_at_depth(&mut self, depth: Depth, child: DisplayObject) {
        self.raw_container_mut().replace_at_depth(depth, child);
    }

    pub fn num_children(&self) -> usize {
        self.container.render_list_len()
    }

    fn child_by_depth(&mut self, depth: Depth) -> Option<&mut DisplayObject> {
        self.container.child_by_depth(depth)
    }

    pub fn first_child_movie_clip(&mut self) -> Option<&MovieClip> {
        if let Some(child) = self.container.first_child() {
            match child {
                DisplayObject::MovieClip(mc) => Some(mc),
                _ => None,
            }
        } else {
            None
        }
    }

    pub fn parse_swf(&mut self, library: &mut MovieLibrary) {
        let swf = self.swf.clone();
        let mut reader = Reader::new(swf.data(), swf.version());
        let tag_callback = |reader: &mut SwfStream<'_>, tag_code, tag_len| {
            match tag_code {
                // TagCode::SetBackgroundColor => self.set_background_color(library, reader),
                TagCode::DefineBitsJpeg3 => self.define_bits_jpeg_3_or_4(library, reader, 3),
                TagCode::DefineBitsJpeg4 => self.define_bits_jpeg_3_or_4(library, reader, 4),
                TagCode::DefineShape => self.define_shape(library, reader, 1),
                TagCode::DefineShape2 => self.define_shape(library, reader, 2),
                TagCode::DefineShape3 => self.define_shape(library, reader, 3),
                TagCode::DefineShape4 => self.define_shape(library, reader, 4),
                TagCode::DefineSprite => return self.define_sprite(library, reader, tag_len),
                TagCode::FrameLabel => self.frame_label(reader),
                TagCode::ShowFrame => self.show_frame(),
                _ => Ok(()),
            }?;
            Ok(ControlFlow::Continue)
        };

        let _ = tag_utils::decode_tags(&mut reader, tag_callback);
    }

    #[inline]
    fn frame_label(&mut self, reader: &mut SwfStream) -> Result<(), Error> {
        let frame_label = reader.read_frame_label()?;
        let label = frame_label
            .label
            .to_str_lossy(SwfStr::encoding_for_version(self.swf.version()));
        self.frame_labels
            .push((self.current_frame, label.into_owned()));
        Ok(())
    }

    #[inline]
    fn show_frame(&mut self) -> Result<(), Error> {
        self.current_frame += 1;
        Ok(())
    }

    #[inline]
    fn define_sprite(
        &mut self,
        library: &mut MovieLibrary,
        reader: &mut SwfStream,
        tag_len: usize,
    ) -> Result<ControlFlow, Error> {
        let start = reader.as_slice();
        let id = reader.read_character_id()?;
        let num_frames = reader.read_u16()?;
        let num_read = reader.pos(start);
        let mut movie_clip = MovieClip::new_with_data(
            id,
            num_frames,
            self.swf.resize_to_reader(reader, tag_len - num_read),
        );
        movie_clip.parse_swf(library);
        library.register_character(id, Character::MovieClip(movie_clip));
        Ok(ControlFlow::Continue)
    }

    #[inline]
    fn define_shape(
        &mut self,
        library: &mut MovieLibrary,
        reader: &mut SwfStream,
        version: u8,
    ) -> Result<(), Error> {
        let swf_shape = reader.read_define_shape(version)?;
        let id = swf_shape.id;
        let graphic = Graphic::from_swf_tag(swf_shape, self.movie().clone());
        library.register_character(id, Character::Graphic(graphic));
        Ok(())
    }

    #[inline]
    fn define_bits_jpeg_3_or_4(
        &mut self,
        library: &mut MovieLibrary,
        reader: &mut SwfStream,
        version: u8,
    ) -> Result<(), Error> {
        let id = reader.read_u16()?;
        let jpeg_len = reader.read_u32()? as usize;
        if version == 4 {
            let _de_blocking = reader.read_u16()?;
        }
        let jpeg_data = reader.read_slice(jpeg_len)?;
        let alpha_data = reader.read_slice_to_end();
        let (width, height) = ruffle_render::utils::decode_define_bits_jpeg_dimensions(jpeg_data)?;
        library.register_character(
            id,
            Character::Bitmap(CompressedBitmap::Jpeg {
                data: jpeg_data.to_owned(),
                alpha: Some(alpha_data.to_owned()),
                width,
                height,
            }),
        );
        Ok(())
    }

    pub fn run_frame_internal(
        &mut self,
        library: &mut MovieLibrary,
        run_display_actions: bool,
        is_action_script_3: bool,
    ) {
        let next_frame: NextFrame = self.determine_next_frame();
        match next_frame {
            NextFrame::Next => {}
            NextFrame::First => {
                // dbg!(self.name(), "end");
                return self.run_goto(library, 1, true);
            }
            NextFrame::Same => {}
        }
        let data = self.swf.clone();
        let mut reader = data.read_from(self.tag_stream_pos);
        let tag_callback = |reader: &mut SwfStream<'_>, tag_code, _tag_len| {
            match tag_code {
                TagCode::PlaceObject if run_display_actions && !is_action_script_3 => {
                    self.place_object(library, reader, 1)
                }
                TagCode::PlaceObject2 if run_display_actions && !is_action_script_3 => {
                    self.place_object(library, reader, 2)
                }
                TagCode::PlaceObject3 if run_display_actions && !is_action_script_3 => {
                    self.place_object(library, reader, 3)
                }
                TagCode::PlaceObject4 if run_display_actions && !is_action_script_3 => {
                    self.place_object(library, reader, 4)
                }
                TagCode::RemoveObject if run_display_actions && !is_action_script_3 => {
                    self.remove_object(reader, 1)
                }
                TagCode::RemoveObject2 if run_display_actions && !is_action_script_3 => {
                    self.remove_object(reader, 2)
                }
                TagCode::PlaceObject if run_display_actions && is_action_script_3 => {
                    self.queue_place_object(reader, 1)
                }
                TagCode::PlaceObject2 if run_display_actions && is_action_script_3 => {
                    self.queue_place_object(reader, 2)
                }
                TagCode::PlaceObject3 if run_display_actions && is_action_script_3 => {
                    self.queue_place_object(reader, 3)
                }
                TagCode::PlaceObject4 if run_display_actions && is_action_script_3 => {
                    self.queue_place_object(reader, 4)
                }
                TagCode::RemoveObject if run_display_actions && is_action_script_3 => {
                    self.queue_remove_object(reader, 1)
                }
                TagCode::RemoveObject2 if run_display_actions && is_action_script_3 => {
                    self.queue_remove_object(reader, 2)
                }
                // TagCode::SetBackgroundColor => self.set_background_color(library, reader),
                TagCode::ShowFrame => return Ok(ControlFlow::Exit),
                _ => Ok(()),
            }?;
            Ok(ControlFlow::Continue)
        };
        let _ = tag_utils::decode_tags(&mut reader, tag_callback);
        let tag_stream_start = self.swf.as_ref().as_ptr() as u64;

        let remove_actions = self.unqueue_removes();

        for (_, tag) in remove_actions {
            let mut reader = data.read_from(tag.tag_start);
            let version = match tag.tag_type {
                QueuedTagAction::Remove(v) => v,
                _ => unreachable!(),
            };

            if let Err(e) = self.remove_object(&mut reader, version) {
                error!("Error running queued tag: {:?}, got {}", tag.tag_type, e);
            }
        }

        self.tag_stream_pos = reader.get_ref().as_ptr() as u64 - tag_stream_start;
        if matches!(next_frame, NextFrame::Next) && is_action_script_3 {
            self.current_frame += 1;
        }
    }

    #[inline]
    fn place_object(
        &mut self,
        library: &mut MovieLibrary,
        reader: &mut SwfStream,
        version: SwfVersion,
    ) -> Result<(), Error> {
        let place_object = if version == 1 {
            reader.read_place_object()
        } else {
            reader.read_place_object_2_or_3(version)
        }?;
        match place_object.action {
            PlaceObjectAction::Place(id) => {
                if let Some(child) =
                    self.instantiate_child(id, place_object.depth, &place_object, library)
                {
                    self.replace_at_depth(place_object.depth, child);
                }
            }
            PlaceObjectAction::Replace(id) => {
                let swf = self.swf.clone();
                let current_frame = self.current_frame;
                if let Some(child) = self.child_by_depth(place_object.depth) {
                    child.replace_with(id, library);
                    child.apply_place_object(&place_object, swf.version());
                    child.set_place_frame(current_frame);
                }
            }
            PlaceObjectAction::Modify => {
                let swf = self.swf.clone();
                if let Some(child) = self.child_by_depth(place_object.depth) {
                    child.apply_place_object(&place_object, swf.version());
                }
            }
        }
        Ok(())
    }

    #[inline]
    fn queue_place_object(
        &mut self,
        reader: &mut SwfStream,
        version: SwfVersion,
    ) -> Result<(), Error> {
        let tag_start = reader.get_ref().as_ptr() as u64 - self.swf.as_ref().as_ptr() as u64;
        let place_object = if version == 1 {
            reader.read_place_object()
        } else {
            reader.read_place_object_2_or_3(version)
        }?;

        let new_tag = QueuedTag {
            tag_type: QueuedTagAction::Place(version),
            tag_start,
        };
        let bucket = self
            .queued_tags
            .entry(place_object.depth as Depth)
            .or_insert_with(|| QueuedTagList::None);
        bucket.queue_add(new_tag);
        Ok(())
    }

    #[inline]
    fn remove_object(&mut self, reader: &mut SwfStream, version: SwfVersion) -> Result<(), Error> {
        let remove_object = if version == 1 {
            reader.read_remove_object_1()
        } else {
            reader.read_remove_object_2()
        }?;
        if let Some(_child) = self.child_by_depth(remove_object.depth) {
            self.raw_container_mut().remove_child(remove_object.depth);
        }
        Ok(())
    }

    #[inline]
    fn queue_remove_object(
        &mut self,
        reader: &mut SwfStream,
        version: SwfVersion,
    ) -> Result<(), Error> {
        let tag_start = reader.get_ref().as_ptr() as u64 - self.swf.as_ref().as_ptr() as u64;
        let remove_object = if version == 1 {
            reader.read_remove_object_1()
        } else {
            reader.read_remove_object_2()
        }?;
        let new_tag = QueuedTag {
            tag_type: QueuedTagAction::Remove(version),
            tag_start,
        };
        let bucket = self
            .queued_tags
            .entry(remove_object.depth as Depth)
            .or_insert_with(|| QueuedTagList::None);
        bucket.queue_remove(new_tag);
        Ok(())
    }

    fn instantiate_child(
        &mut self,
        id: CharacterId,
        depth: Depth,
        place_object: &swf::PlaceObject,
        library: &mut MovieLibrary,
    ) -> Option<DisplayObject> {
        let child = self.instantiate_by_id(id, library);
        match child {
            Ok(mut child) => {
                child.set_depth(depth);
                child.set_place_frame(self.current_frame);
                child.apply_place_object(place_object, self.swf.version());
                if self.is_root() {
                    // 将初始位置设置为 (0, 0)
                    child.set_matrix(Matrix::IDENTITY);
                }
                if let Some(name) = &place_object.name {
                    let name = name
                        .to_str_lossy(SwfStr::encoding_for_version(self.swf.version()))
                        .into_owned();
                    child.set_name(Some(name));
                }
                if let Some(clip_depth) = place_object.clip_depth {
                    child.set_clip_depth(clip_depth);
                }
                child.post_instantiation(library);
                child.enter_frame(library);
                Some(child)
            }
            Err(_e) => None,
        }
    }

    fn instantiate_by_id(
        &mut self,
        id: CharacterId,
        library: &mut MovieLibrary,
    ) -> anyhow::Result<DisplayObject> {
        if let Some(character) = library.character(id) {
            match character.clone() {
                Character::MovieClip(movie_clip) => Ok(movie_clip.into()),
                Character::Graphic(graphic) => Ok(graphic.into()),
                _ => unreachable!("Character id 不在库中"),
            }
        } else {
            Err(anyhow!("Character id 不在库中"))
        }
    }

    pub fn run_goto(&mut self, library: &mut MovieLibrary, frame: FrameNumber, is_implicit: bool) {
        // let frame_before_rewind = self.current_frame;
        let mut goto_commands: Vec<GotoPlaceObject> = Vec::new();

        let is_rewind = if frame <= self.current_frame {
            self.tag_stream_pos = 0;
            self.current_frame = 0;
            true
        } else {
            false
        };
        let from_frame = self.current_frame;
        let tag_stream_start = self.swf.as_ref().as_ptr() as u64;
        let mut frame_pos = self.tag_stream_pos;
        let data = self.swf.clone();
        let mut index = 0;

        let clamped_frame = frame.min(max(self.total_frames, 0));
        let mut reader = data.read_from(frame_pos);
        while self.current_frame < clamped_frame && !reader.get_ref().is_empty() {
            self.current_frame += 1;
            frame_pos = reader.get_ref().as_ptr() as u64 - tag_stream_start;

            let tag_callback = |reader: &mut _, tag_code, _tag_len| {
                match tag_code {
                    TagCode::PlaceObject => {
                        index += 1;
                        self.goto_place_object(reader, 1, &mut goto_commands, is_rewind, index)
                    }
                    TagCode::PlaceObject2 => {
                        index += 1;
                        self.goto_place_object(reader, 2, &mut goto_commands, is_rewind, index)
                    }
                    TagCode::PlaceObject3 => {
                        index += 1;
                        self.goto_place_object(reader, 3, &mut goto_commands, is_rewind, index)
                    }
                    TagCode::PlaceObject4 => {
                        index += 1;
                        self.goto_place_object(reader, 4, &mut goto_commands, is_rewind, index)
                    }
                    TagCode::RemoveObject => self.goto_remove_object(
                        reader,
                        1,
                        &mut goto_commands,
                        is_rewind,
                        from_frame,
                    ),
                    TagCode::RemoveObject2 => self.goto_remove_object(
                        reader,
                        2,
                        &mut goto_commands,
                        is_rewind,
                        from_frame,
                    ),
                    TagCode::ShowFrame => return Ok(ControlFlow::Exit),
                    _ => Ok(()),
                }?;
                Ok(ControlFlow::Continue)
            };
            let _ = tag_utils::decode_tags(&mut reader, tag_callback);
        }
        let hit_target_frame = self.current_frame == frame;

        let render_list = self.raw_container().render_list();
        if is_rewind {
            let children: SmallVec<[_; 16]> = render_list
                .iter()
                .filter(|display_id| {
                    if let Some(display_object) = self.container.display_objects().get(display_id) {
                        display_object.place_frame() > frame
                    } else {
                        false
                    }
                })
                .map(|display_id| {
                    self.container
                        .display_objects()
                        .get(display_id)
                        .unwrap()
                        .depth()
                })
                .collect();

            for child in children {
                self.raw_container_mut().remove_child(child);
            }
        }
        let movie = self.movie();
        let run_goto_command = |clip: &mut MovieClip,
                                params: &GotoPlaceObject<'_>,
                                library: &mut MovieLibrary| {
            let child_entry = clip.child_by_depth(params.depth());

            if movie.is_action_script_3() && is_implicit && child_entry.is_none() {
                let new_tag = QueuedTag {
                    tag_type: QueuedTagAction::Place(params.version),
                    tag_start: params.tag_start,
                };
                let bucket = clip
                    .queued_tags
                    .entry(params.place_object.depth as Depth)
                    .or_insert_with(|| QueuedTagList::None);
                bucket.queue_add(new_tag);
                return;
            }

            match (params.place_object.action, child_entry, is_rewind) {
                (_, Some(prev_child), true) | (PlaceObjectAction::Modify, Some(prev_child), _) => {
                    prev_child.apply_place_object(&params.place_object, movie.version());
                }
                (PlaceObjectAction::Replace(id), Some(prev_child), _) => {
                    prev_child.replace_with(id, library);
                    prev_child.apply_place_object(&params.place_object, movie.version());
                    prev_child.set_place_frame(params.frame);
                }
                (PlaceObjectAction::Place(id), _, _)
                | (swf::PlaceObjectAction::Replace(id), _, _) => {
                    if let Some(mut child) =
                        clip.instantiate_child(id, params.depth(), &params.place_object, library)
                    {
                        // Set the place frame to the frame where the object *would* have been placed.
                        child.set_place_frame(params.frame);
                        clip.replace_at_depth(params.depth(), child);
                    }
                }
                _ => {
                    error!("Unhandled goto command: {:?}", &params.place_object);
                }
            }
        };

        goto_commands.sort_by_key(|params| params.index);

        goto_commands
            .iter()
            .filter(|params| params.frame < frame)
            .for_each(|goto| run_goto_command(self, goto, library));
        if hit_target_frame {
            self.current_frame -= 1;
            self.tag_stream_pos = frame_pos;
            self.run_frame_internal(library, false, self.movie().is_action_script_3());
        } else {
            self.current_frame = clamped_frame;
        }

        goto_commands
            .iter()
            .filter(|params| params.frame >= frame)
            .for_each(|goto| run_goto_command(self, goto, library));
    }

    #[inline]
    fn goto_place_object<'a>(
        &mut self,
        reader: &mut SwfStream<'a>,
        version: SwfVersion,
        goto_commands: &mut Vec<GotoPlaceObject<'a>>,
        is_rewind: bool,
        index: usize,
    ) -> Result<(), Error> {
        let tag_start = reader.get_ref().as_ptr() as u64 - self.swf.as_ref().as_ptr() as u64;
        let place_object = if version == 1 {
            reader.read_place_object()
        } else {
            reader.read_place_object_2_or_3(version)
        }?;
        let depth: Depth = place_object.depth;
        let mut goto_place = GotoPlaceObject::new(
            self.current_frame,
            place_object,
            is_rewind,
            index,
            tag_start,
            version,
        );
        if let Some(i) = goto_commands.iter().position(|o| o.depth() == depth) {
            goto_commands[i].merge(&mut goto_place);
        } else {
            goto_commands.push(goto_place);
        }
        Ok(())
    }

    #[inline]
    fn goto_remove_object(
        &mut self,
        reader: &mut SwfStream,
        version: SwfVersion,
        goto_commands: &mut Vec<GotoPlaceObject>,
        is_rewind: bool,
        from_frame: FrameNumber,
    ) -> Result<(), Error> {
        let remove_object = if version == 1 {
            reader.read_remove_object_1()
        } else {
            reader.read_remove_object_2()
        }?;
        let depth: Depth = remove_object.depth;
        if let Some(i) = goto_commands.iter().position(|o| o.depth() == depth) {
            goto_commands.swap_remove(i);
        }
        if !is_rewind {
            let to_frame = self.current_frame;
            self.current_frame = from_frame;

            let child = self.child_by_depth(depth);

            if let Some(child) = child {
                let depth = child.depth();
                self.raw_container_mut().remove_child(depth);
            }
            self.current_frame = to_frame;
        }
        Ok(())
    }

    fn playing(&self) -> bool {
        self.flags.contains(MovieClipFlags::PLAYING)
    }
    pub fn set_playing(&mut self, playing: bool) {
        self.flags.set(MovieClipFlags::PLAYING, playing);
    }
    pub fn play(&mut self) {
        if self.total_frames > 1 {
            self.set_playing(true);
        }
    }

    pub fn stop(&mut self) {
        self.set_playing(false);
    }

    fn unqueue_adds(&mut self) -> Vec<(Depth, QueuedTag)> {
        let mut unqueued: Vec<_> = self
            .queued_tags
            .iter_mut()
            .filter_map(|(d, b)| b.unqueue_add().map(|b| (*d, b)))
            .collect();
        unqueued.sort_by(|(_, t1), (_, t2)| t1.tag_start.cmp(&t2.tag_start));
        for (depth, _tag) in unqueued.iter() {
            if matches!(self.queued_tags.get(depth), Some(QueuedTagList::None)) {
                self.queued_tags.remove(depth);
            }
        }
        unqueued
    }
    fn unqueue_removes(&mut self) -> Vec<(Depth, QueuedTag)> {
        let mut unqueued: Vec<_> = self
            .queued_tags
            .iter_mut()
            .filter_map(|(d, b)| b.unqueue_remove().map(|b| (*d, b)))
            .collect();
        unqueued.sort_by(|(_, t1), (_, t2)| t1.tag_start.cmp(&t2.tag_start));

        for (depth, _tag) in unqueued.iter() {
            if matches!(self.queued_tags.get(depth), Some(QueuedTagList::None)) {
                self.queued_tags.remove(depth);
            }
        }
        unqueued
    }
    pub fn tag_stream_len(&self) -> usize {
        self.swf.end - self.swf.start
    }
    pub fn total_bytes(self) -> i32 {
        // For a loaded SWF, returns the uncompressed size of the SWF.
        // Otherwise, returns the size of the tag list in the clip's DefineSprite tag.
        if self.is_root() {
            self.movie().uncompressed_len()
        } else {
            self.tag_stream_len() as i32
        }
    }

    pub fn goto_frame(&mut self, library: &mut MovieLibrary, frame: FrameNumber, stop: bool) {
        if stop {
            self.stop();
        } else {
            self.play();
        }

        let frame = frame.max(1);

        if frame != self.current_frame {
            self.run_goto(library, frame, false)
        }
    }

    pub fn determine_next_frame(&self) -> NextFrame {
        if self.current_frame < self.total_frames {
            NextFrame::Next
        } else if self.total_frames > 1 {
            NextFrame::First
        } else {
            NextFrame::Same
        }
    }

    pub fn query_movie_clip(&mut self, arg: &str) -> Option<&mut Self> {
        if self.name() == Some(arg) {
            return Some(self);
        } else {
            for child in self.raw_container_mut().display_objects_mut().values_mut() {
                if let DisplayObject::MovieClip(movie_clip) = child {
                    if movie_clip.name() == Some(arg) {
                        return Some(movie_clip);
                    } else {
                        return movie_clip.query_movie_clip(arg);
                    }
                }
            }
        }
        None
    }
}

impl TDisplayObject for MovieClip {
    fn base_mut(&mut self) -> &mut DisplayObjectBase {
        &mut self.base
    }

    fn base(&self) -> &DisplayObjectBase {
        &self.base
    }

    fn character_id(&self) -> CharacterId {
        self.id
    }

    fn as_movie(&mut self) -> Option<MovieClip> {
        Some(self.clone())
    }

    fn enter_frame(&mut self, library: &mut MovieLibrary) {
        let is_playing = self.playing();
        let data = self.swf.clone();

        // let skip_frame = self.base().should_skip_next_enter_frame();

        for child in self.raw_container().render_list().iter().rev() {
            if let Some(display_object) = self
                .raw_container_mut()
                .display_objects_mut()
                .get_mut(child)
            {
                display_object.enter_frame(library);
            }

            // if skip_frame {
            //     child.base_mut().set_skip_next_enter_frame(true);
            // }
        }
        // if skip_frame {
        //     self.base_mut().set_skip_next_enter_frame(false);
        //     return;
        // }
        if self.movie().is_action_script_3() {
            if is_playing {
                self.run_frame_internal(library, true, true);
            }
            let place_actions = self.unqueue_adds();

            for (_, tag) in place_actions {
                let mut reader = data.read_from(tag.tag_start);
                let version = match tag.tag_type {
                    QueuedTagAction::Place(v) => v,
                    _ => unreachable!(),
                };
                if let Err(e) = self.place_object(library, &mut reader, version) {
                    info!("Error placing object: {:?}", e);
                }
            }
        }
    }

    fn movie(&self) -> Arc<SwfMovie> {
        self.swf.movie.clone()
    }
}

#[derive(Default, Debug, Eq, PartialEq, Clone, Copy)]
pub enum QueuedTagList {
    #[default]
    None,
    Add(QueuedTag),
    Remove(QueuedTag),
    RemoveThenAdd(QueuedTag, QueuedTag),
}

impl QueuedTagList {
    fn queue_add(&mut self, add_tag: QueuedTag) {
        let new = match self {
            QueuedTagList::None => QueuedTagList::Add(add_tag),
            QueuedTagList::Add(existing) => {
                // Flash player traces "Warning: Failed to place object at depth 1.",
                // so let's log a warning too.
                QueuedTagList::Add(*existing)
            }
            QueuedTagList::Remove(r) => QueuedTagList::RemoveThenAdd(*r, add_tag),
            QueuedTagList::RemoveThenAdd(r, _) => QueuedTagList::RemoveThenAdd(*r, add_tag),
        };

        *self = new;
    }

    fn queue_remove(&mut self, remove_tag: QueuedTag) {
        let new = match self {
            QueuedTagList::None => QueuedTagList::Remove(remove_tag),
            QueuedTagList::Add(_) => QueuedTagList::None,
            QueuedTagList::Remove(_) => QueuedTagList::Remove(remove_tag),
            QueuedTagList::RemoveThenAdd(r, _) => QueuedTagList::Remove(*r),
        };

        *self = new;
    }

    fn unqueue_add(&mut self) -> Option<QueuedTag> {
        let (new_queue, return_val) = match self {
            QueuedTagList::None => (QueuedTagList::None, None),
            QueuedTagList::Add(a) => (QueuedTagList::None, Some(*a)),
            QueuedTagList::Remove(r) => (QueuedTagList::Remove(*r), None),
            QueuedTagList::RemoveThenAdd(r, a) => (QueuedTagList::Remove(*r), Some(*a)),
        };

        *self = new_queue;

        return_val
    }

    fn unqueue_remove(&mut self) -> Option<QueuedTag> {
        let (new_queue, return_val) = match self {
            QueuedTagList::None => (QueuedTagList::None, None),
            QueuedTagList::Add(a) => (QueuedTagList::Add(*a), None),
            QueuedTagList::Remove(r) => (QueuedTagList::None, Some(*r)),
            QueuedTagList::RemoveThenAdd(r, a) => (QueuedTagList::Add(*a), Some(*r)),
        };

        *self = new_queue;

        return_val
    }
}

#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub struct QueuedTag {
    pub tag_type: QueuedTagAction,
    pub tag_start: u64,
}

/// The type of queued tag.
///
/// The u8 parameter is the tag version.
#[derive(Debug, Eq, PartialEq, Clone, Copy)]
pub enum QueuedTagAction {
    Place(u8),
    Remove(u8),
}

#[derive(Debug)]
pub struct GotoPlaceObject<'a> {
    frame: FrameNumber,

    place_object: swf::PlaceObject<'a>,

    index: usize,

    tag_start: u64,

    version: SwfVersion,
}

impl<'a> GotoPlaceObject<'a> {
    fn new(
        frame: FrameNumber,
        mut place_object: swf::PlaceObject<'a>,
        is_rewind: bool,
        index: usize,
        tag_start: u64,
        version: SwfVersion,
    ) -> Self {
        if is_rewind {
            if let swf::PlaceObjectAction::Place(_) = place_object.action {
                if place_object.matrix.is_none() {
                    place_object.matrix = Some(Default::default());
                }
                if place_object.color_transform.is_none() {
                    place_object.color_transform = Some(Default::default());
                }
                if place_object.ratio.is_none() {
                    place_object.ratio = Some(Default::default());
                }
                if place_object.blend_mode.is_none() {
                    place_object.blend_mode = Some(Default::default());
                }
                if place_object.is_bitmap_cached.is_none() {
                    place_object.is_bitmap_cached = Some(Default::default());
                }
                if place_object.background_color.is_none() {
                    place_object.background_color = Some(Color::from_rgba(0));
                }
                if place_object.filters.is_none() {
                    place_object.filters = Some(Default::default());
                }
            }
        }
        Self {
            frame,
            place_object,
            index,
            tag_start,
            version,
        }
    }

    #[inline]
    fn depth(&self) -> Depth {
        self.place_object.depth
    }

    fn merge(&mut self, next: &mut GotoPlaceObject<'a>) {
        let cur_place = &mut self.place_object;
        let next_place = &mut next.place_object;
        match (cur_place.action, next_place.action) {
            (cur, PlaceObjectAction::Modify) => {
                cur_place.action = cur;
            }
            (_, new) => {
                cur_place.action = new;
                self.frame = next.frame;
            }
        };
        if next_place.matrix.is_some() {
            cur_place.matrix = next_place.matrix.take();
        }
        if next_place.color_transform.is_some() {
            cur_place.color_transform = next_place.color_transform.take();
        }
        if next_place.ratio.is_some() {
            cur_place.ratio = next_place.ratio.take();
        }
        if next_place.blend_mode.is_some() {
            cur_place.blend_mode = next_place.blend_mode.take();
        }
        if next_place.is_bitmap_cached.is_some() {
            cur_place.is_bitmap_cached = next_place.is_bitmap_cached.take();
        }
        if next_place.is_visible.is_some() {
            cur_place.is_visible = next_place.is_visible.take();
        }
        if next_place.background_color.is_some() {
            cur_place.background_color = next_place.background_color.take();
        }
        if next_place.filters.is_some() {
            cur_place.filters = next_place.filters.take();
        }
    }
}

================
File: src/swf/library.rs
================
use std::collections::HashMap;

use swf::CharacterId;

use super::{
    characters::{Character, CompressedBitmap},
    display_object::graphic::Graphic,
};

#[derive(Clone, Default)]
pub struct MovieLibrary {
    characters: HashMap<CharacterId, Character>,
    pub instance_count: u16,
}

impl MovieLibrary {
    pub fn new() -> Self {
        Self {
            characters: HashMap::new(),
            instance_count: 0,
        }
    }
    pub fn register_character(&mut self, id: CharacterId, character: Character) {
        self.characters.insert(id, character);
    }

    pub fn character(&self, id: CharacterId) -> Option<&Character> {
        self.characters.get(&id)
    }
    pub fn character_mut(&mut self, id: CharacterId) -> Option<&mut Character> {
        self.characters.get_mut(&id)
    }
    pub fn characters(&self) -> &HashMap<CharacterId, Character> {
        &self.characters
    }
    pub fn characters_mut(&mut self) -> &mut HashMap<CharacterId, Character> {
        &mut self.characters
    }

    pub fn get_graphic(&self, id: CharacterId) -> Option<Graphic> {
        if let Some(Character::Graphic(graphic)) = self.characters.get(&id) {
            Some(graphic.clone())
        } else {
            None
        }
    }

    pub fn get_bitmap(&self, id: CharacterId) -> Option<CompressedBitmap> {
        if let Some(Character::Bitmap(bitmap)) = self.characters.get(&id) {
            Some(bitmap.clone())
        } else {
            None
        }
    }
}

================
File: src/swf/tag_utils.rs
================
use bevy::log::error;
use std::sync::Arc;
use swf::{CharacterId, Fixed8, HeaderExt, Rectangle, TagCode, Twips};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("Couldn't read SWF: {0}")]
    InvalidSwf(#[from] swf::error::Error),

    #[error("Couldn't register bitmap: {0}")]
    InvalidBitmap(#[from] ruffle_render::error::Error),

    // #[error("Couldn't register font: {0}")]
    // InvalidFont(#[from] ttf_parser::FaceParsingError),
    #[error("Attempted to set symbol classes on movie without any")]
    NoSymbolClasses,

    #[error("Attempted to preload video frames into non-video character {0}")]
    PreloadVideoIntoInvalidCharacter(CharacterId),

    #[error("IO Error: {0}")]
    IO(#[from] std::io::Error),

    #[error("Invalid SWF url")]
    InvalidSwfUrl,
}

unsafe impl Send for Error {}
unsafe impl Sync for Error {}

/// Whether or not to end tag decoding.
pub enum ControlFlow {
    /// Stop decoding after this tag.
    Exit,

    /// Continue decoding the next tag.
    Continue,
}

pub type SwfStream<'a> = swf::read::Reader<'a>;

/// An open, fully parsed SWF movie ready to play back, either in a Player or a
/// MovieClip.
#[derive(Debug, Clone)]
pub struct SwfMovie {
    /// The SWF header parsed from the data stream.
    header: HeaderExt,

    /// Uncompressed SWF data.
    data: Vec<u8>,

    /// The suggest encoding for this SWF.
    encoding: &'static swf::Encoding,

    /// The compressed length of the entire data stream
    compressed_len: usize,

    /// Whether this SwfMovie actually represents a loaded movie or fills in for
    /// something else, like an loaded image, filler movie, or error state.
    is_movie: bool,
}

impl SwfMovie {
    /// Construct an empty movie.
    pub fn empty(swf_version: u8) -> Self {
        Self {
            header: HeaderExt::default_with_swf_version(swf_version),
            data: vec![],
            encoding: swf::UTF_8,
            compressed_len: 0,
            is_movie: false,
        }
    }

    /// Construct a movie based on the contents of the SWF data stream.
    pub fn from_data(swf_data: &[u8]) -> Result<Self, Error> {
        let compressed_len = swf_data.len();
        let swf_buf = swf::read::decompress_swf(swf_data)?;
        let encoding = swf::SwfStr::encoding_for_version(swf_buf.header.version());
        let movie = Self {
            header: swf_buf.header,
            data: swf_buf.data,
            encoding,
            compressed_len,
            is_movie: true,
        };
        Ok(movie)
    }

    pub fn header(&self) -> &HeaderExt {
        &self.header
    }

    /// Get the version of the SWF.
    pub fn version(&self) -> u8 {
        self.header.version()
    }

    pub fn data(&self) -> &[u8] {
        &self.data
    }

    /// Returns the suggested string encoding for the given SWF version.
    /// For SWF version 6 and higher, this is always UTF-8.
    /// For SWF version 5 and lower, this is locale-dependent,
    /// and we default to WINDOWS-1252.
    pub fn encoding(&self) -> &'static swf::Encoding {
        self.encoding
    }

    /// The width of the movie in twips.
    pub fn width(&self) -> Twips {
        self.header.stage_size().width()
    }

    /// The height of the movie in twips.
    pub fn height(&self) -> Twips {
        self.header.stage_size().height()
    }

    pub fn compressed_len(&self) -> usize {
        self.compressed_len
    }

    pub fn uncompressed_len(&self) -> i32 {
        self.header.uncompressed_len()
    }

    pub fn is_action_script_3(&self) -> bool {
        self.header.is_action_script_3()
    }

    pub fn stage_size(&self) -> &Rectangle<Twips> {
        self.header.stage_size()
    }

    pub fn num_frames(&self) -> u16 {
        self.header.num_frames()
    }

    pub fn frame_rate(&self) -> Fixed8 {
        self.header.frame_rate()
    }

    pub fn is_movie(&self) -> bool {
        self.is_movie
    }
}

/// A shared-ownership reference to some portion of an SWF data stream.
#[derive(Debug, Clone)]
pub struct SwfSlice {
    pub movie: Arc<SwfMovie>,
    pub start: usize,
    pub end: usize,
}

impl Default for SwfSlice {
    fn default() -> Self {
        Self {
            movie: Arc::new(SwfMovie::empty(0)),
            start: 0,
            end: 0,
        }
    }
}

impl From<Arc<SwfMovie>> for SwfSlice {
    fn from(movie: Arc<SwfMovie>) -> Self {
        let end = movie.data().len();

        Self {
            movie,
            start: 0,
            end,
        }
    }
}

impl AsRef<[u8]> for SwfSlice {
    #[inline]
    fn as_ref(&self) -> &[u8] {
        self.data()
    }
}

impl SwfSlice {
    /// Creates an empty SwfSlice.
    #[inline]
    pub fn empty(movie: Arc<SwfMovie>) -> Self {
        Self {
            movie: movie.clone(),
            start: 0,
            end: movie.data().len(),
        }
    }

    /// Creates an empty SwfSlice of the same movie.
    #[inline]
    pub fn copy_empty(&self) -> Self {
        Self::empty(self.movie.clone())
    }

    /// Construct a new SwfSlice from a regular slice.
    ///
    /// This function returns None if the given slice is not a subslice of the
    /// current slice.
    pub fn to_subslice(&self, slice: &[u8]) -> Self {
        let self_pval = self.movie.data().as_ptr() as usize;
        let slice_pval = slice.as_ptr() as usize;

        if (self_pval + self.start) <= slice_pval && slice_pval < (self_pval + self.end) {
            Self {
                movie: self.movie.clone(),
                start: slice_pval - self_pval,
                end: (slice_pval - self_pval) + slice.len(),
            }
        } else {
            self.copy_empty()
        }
    }

    /// Construct a new SwfSlice from a Reader and a size.
    ///
    /// This is intended to allow constructing references to the contents of a
    /// given SWF tag. You just need the current reader and the size of the tag
    /// you want to reference.
    ///
    /// The returned slice may or may not be a subslice of the current slice.
    /// If the resulting slice would be outside the bounds of the underlying
    /// movie, or the given reader refers to a different underlying movie, this
    /// function returns an empty slice.
    pub fn resize_to_reader(&self, reader: &mut SwfStream<'_>, size: usize) -> Self {
        if self.movie.data().as_ptr() as usize <= reader.get_ref().as_ptr() as usize
            && (reader.get_ref().as_ptr() as usize)
                < self.movie.data().as_ptr() as usize + self.movie.data().len()
        {
            let outer_offset =
                reader.get_ref().as_ptr() as usize - self.movie.data().as_ptr() as usize;
            let new_start = outer_offset;
            let new_end = outer_offset + size;

            let len = self.movie.data().len();

            if new_start < len && new_end < len {
                Self {
                    movie: self.movie.clone(),
                    start: new_start,
                    end: new_end,
                }
            } else {
                self.copy_empty()
            }
        } else {
            self.copy_empty()
        }
    }

    /// Construct a new SwfSlice from a start and an end.
    ///
    /// The start and end values will be relative to the current slice.
    /// Furthermore, this function will yield an empty slice if the calculated slice
    /// would be invalid (e.g. negative length) or would extend past the end of
    /// the current slice.
    pub fn to_start_and_end(&self, start: usize, end: usize) -> Self {
        let new_start = self.start + start;
        let new_end = self.start + end;

        if new_start <= new_end {
            if let Some(result) = self.movie.data().get(new_start..new_end) {
                self.to_subslice(result)
            } else {
                self.copy_empty()
            }
        } else {
            self.copy_empty()
        }
    }

    /// Convert the SwfSlice into a standard data slice.
    pub fn data(&self) -> &[u8] {
        &self.movie.data()[self.start..self.end]
    }

    /// Get the version of the SWF this data comes from.
    pub fn version(&self) -> u8 {
        self.movie.header().version()
    }

    /// Checks if this slice is empty
    pub fn is_empty(&self) -> bool {
        self.end == self.start
    }

    /// Construct a reader for this slice.
    ///
    /// The `from` parameter is the offset to start reading the slice from.
    pub fn read_from(&self, from: u64) -> swf::read::Reader<'_> {
        swf::read::Reader::new(&self.data()[from as usize..], self.movie.version())
    }

    /// Get the length of the SwfSlice.
    pub fn len(&self) -> usize {
        self.end - self.start
    }
}

/// Decode tags from a SWF stream reader.
///
/// The given `tag_callback` will be called for each decoded tag. It will be
/// provided with the stream to read from, the tag code read, and the tag's
/// size. The callback is responsible for (optionally) parsing the contents of
/// the tag; otherwise, it will be skipped.
///
/// Decoding will terminate when the following conditions occur:
///
///  * The `tag_callback` calls for the decoding to finish.
///  * The decoder encounters a tag longer than the underlying SWF slice
///    (indicated by returning false)
///  * The SWF stream is otherwise corrupt or unreadable (indicated as an error
///    result)
///
/// Decoding will also log tags longer than the SWF slice, error messages
/// yielded from the tag callback, and unknown tags. It will *only* return an
/// error message if the SWF tag itself could not be parsed. Other forms of
/// irregular decoding will be signalled by returning false.
pub fn decode_tags<'a, F>(reader: &mut SwfStream<'a>, mut tag_callback: F) -> Result<bool, Error>
where
    F: for<'b> FnMut(&'b mut SwfStream<'a>, TagCode, usize) -> Result<ControlFlow, Error>,
{
    loop {
        let (tag_code, tag_len) = reader.read_tag_code_and_length()?;
        if tag_len > reader.get_ref().len() {
            error!("Unexpected EOF when reading tag");
            *reader.get_mut() = &reader.get_ref()[reader.get_ref().len()..];
            return Ok(false);
        }

        let tag_slice = &reader.get_ref()[..tag_len];
        let end_slice = &reader.get_ref()[tag_len..];
        if let Some(tag) = TagCode::from_u16(tag_code) {
            *reader.get_mut() = tag_slice;
            let result = tag_callback(reader, tag, tag_len);

            match result {
                Err(e) => {
                    // tracing::error!("Error running definition tag: {:?}, got {}", tag, e)
                    eprint!("Error running definition tag: {:?}, got {}", tag, e)
                }
                Ok(ControlFlow::Exit) => {
                    *reader.get_mut() = end_slice;
                    break;
                }
                Ok(ControlFlow::Continue) => {}
            }
        } else {
            error!("Unknown tag code: {:?}", tag_code);
        }

        *reader.get_mut() = end_slice;
    }

    Ok(true)
}

================
File: swf_macro/Cargo.toml
================
[package]
name = "swf_macro"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true

[dependencies]
syn = "1.0"
quote = "1.0"

================
File: swf_macro/src/lib.rs
================
use proc_macro::{self, TokenStream};
use quote::quote;
use syn::{Data, DeriveInput, Fields};

#[proc_macro_derive(SwfMaterial)]
pub fn swf_material_derive(input: TokenStream) -> TokenStream {
    // 解析输入的 Rust 代码为语法树
    let ast: DeriveInput = syn::parse(input).unwrap();
    // 提取结构体的名称
    let name = &ast.ident;
    // 判断结构体字段含有transform
    let has_transform_field = if let Data::Struct(data_struct) = ast.data {
        match data_struct.fields {
            Fields::Named(ref fields_named) => fields_named
                .named
                .iter()
                .any(|f| f.ident.as_ref().unwrap() == "transform"),
            _ => false,
        }
    } else {
        false
    };
    if !has_transform_field {
        return quote! {
            compile_error!("derive(SwfMaterial) requires a struct with a `transform` field");
        }
        .into();
    }
    let gen = quote! {
        impl SwfMaterial for #name {
            fn update_swf_material(&mut self, swf_transform: SwfTransform) {
                self.transform = swf_transform
            }
            fn world_transform(&self) -> Mat4 {
                self.transform.world_transform
            }
            fn set_blend_mode(&mut self, blend_mode: BlendMode2d) {
                self.blend_mode = blend_mode;
            }
        }
    };
    gen.into()
}



================================================================
End of Codebase
================================================================
